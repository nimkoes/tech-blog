# 네트워크 트래픽 처리 흐름 정리

## 개요

이 문서는 `www.my-app.com`에서 `GET /my-app/data` 요청을 보낼 때, 로컬 PC부터 Azure AKS의 Spring Boot 서버까지 이어지는 네트워크 트래픽의 매우 구체적인 처리 과정을 설명합니다.

## 네트워크 장비 개요

네트워크 트래픽이 처리되는 과정에서 여러 네트워크 장비들이 각각의 역할을 수행합니다:

**주요 네트워크 장비들**

- **로컬 PC**: 사용자의 요청을 생성하고 네트워크로 전송하는 출발점
- **인터넷 공유기**: 가정이나 사무실의 여러 기기를 인터넷에 연결하는 중간 다리 역할
- **스위치**: 네트워크 내에서 패킷을 정확한 목적지로 전달하는 교통 정리 역할
- **라우터**: 서로 다른 네트워크 간의 패킷을 전달하는 우체국 역할

**쉽게 이해하기**

- 로컬 PC는 마치 편지를 쓰는 사람과 같습니다
- 인터넷 공유기는 마치 아파트의 우체통과 같습니다
- 스위치는 마치 건물 내부의 안내원과 같습니다
- 라우터는 마치 도시 간 우편물을 전달하는 우체국과 같습니다

## 시나리오 설정

**요청 정보**

- URL: `https://www.my-app.com/my-app/data`
- HTTP 메서드: GET
- 사용자 위치: 서울시 강남구 사무실
- 네트워크: 무선 Wi-Fi (KT 인터넷)

**대상 시스템**

- 클라우드: Microsoft Azure
- 컨테이너 오케스트레이션: Azure Kubernetes Service (AKS)
- 프론트엔드: Nginx 웹서버
- 백엔드: Spring Boot 애플리케이션

## 1단계: 로컬 PC에서의 요청 시작

**이 단계의 목적**: 사용자의 요청을 네트워크로 전송할 수 있는 형태로 변환하기 위함

**왜 필요한가?**

- 사용자가 브라우저에 입력한 URL은 사람이 이해할 수 있는 형태
- 네트워크로 전송하려면 컴퓨터가 이해할 수 있는 프로토콜 형태로 변환해야 함
- HTTP 요청 헤더에는 서버가 요청을 올바르게 처리하기 위한 정보가 포함됨

### 1.1 애플리케이션 계층 (Application Layer)

**브라우저 내부 처리**

- 사용자가 브라우저 주소창에 `https://www.my-app.com/my-app/data` 입력
- 브라우저가 URL을 파싱하여 다음 정보 추출:
  - 프로토콜: HTTPS
  - 호스트명: www.my-app.com
  - 경로: /my-app/data
  - 포트: 443 (HTTPS 기본 포트)

**HTTP 요청 생성**

```
GET /my-app/data HTTP/1.1
Host: www.my-app.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ko-KR,ko;q=0.9,en;q=0.8
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

**왜 이 단계가 필요한가?**

- 서버가 어떤 데이터를 요청하는지 명확히 알려주기 위함
- 서버가 클라이언트의 능력(지원하는 언어, 압축 방식 등)을 파악하기 위함
- 보안을 위해 HTTPS 프로토콜을 사용하기 위함

### 1.2 표현 계층 (Presentation Layer)

**데이터 인코딩 및 암호화 준비**

- HTTP 헤더와 본문을 UTF-8로 인코딩
- HTTPS 사용으로 TLS/SSL 암호화 준비
- 브라우저가 지원하는 암호화 스위트 목록 생성:
  - TLS_AES_256_GCM_SHA384
  - TLS_CHACHA20_POLY1305_SHA256
  - TLS_AES_128_GCM_SHA256

### 1.3 세션 계층 (Session Layer)

**TLS 핸드셰이크 준비**

- 브라우저가 TLS 1.3 핸드셰이크를 위한 랜덤 값 생성
- ClientHello 메시지 구성 준비
- 세션 재사용을 위한 Session ID 생성

## 2단계: DNS 질의 과정

### 2.1 DNS 질의 시작

**상태 스냅샷 #1: 브라우저 DNS 캐시 확인**

**브라우저 내부 상태**

```
브라우저 DNS 캐시 테이블:
┌────────────────┬────────────────┬──────┐
│ domain name    │ IP address     │ TTL  │
├────────────────┼────────────────┼──────┤
│ www.google.com │ 142.250.191.78 │ 300s │
│ www.naver.com  │ 223.130.195.95 │ 600s │
│ www.my-app.com │ -              │ -    │
└────────────────┴────────────────┴──────┘
```

**처리 과정**

1. 브라우저가 `www.my-app.com`을 캐시에서 검색
2. 캐시 미스 발생 → 운영체제 DNS 리졸버 호출
3. 브라우저 상태: "DNS 캐시에서 찾지 못함, OS에 질의 요청"

**쉽게 이해하기**

- 브라우저는 마치 개인 전화번호부를 먼저 확인하는 것과 같습니다
- "www.my-app.com의 번호가 있나?" 확인 후 없으면 안내데스크에 물어봅니다

**처리 주체**: 브라우저 (Chrome, Safari, Firefox 등)

**로컬 DNS 캐시 확인**

- 브라우저가 먼저 로컬 DNS 캐시 확인
- Windows의 경우 `C:\Windows\System32\drivers\etc\hosts` 파일 확인
- Mac의 경우 `/etc/hosts` 파일 확인
- 브라우저 자체 DNS 캐시 확인

**로컬 DNS 캐시 미스 시**

- 브라우저가 운영체제의 DNS 리졸버 호출
- Windows의 경우 `nslookup` 또는 `GetHostByName` API 호출
- Mac의 경우 `dscacheutil` 또는 `getaddrinfo` API 호출

**쉽게 이해하기**

- 브라우저는 먼저 "이 주소를 최근에 찾아본 적이 있나?" 확인
- 마치 전화번호부에서 자주 쓰는 번호를 먼저 찾아보는 것과 같음
- 찾아본 적이 없으면 운영체제에게 "이 주소의 전화번호를 알아봐" 요청

### 2.2 DNS 리졸버 동작

**상태 스냅샷 #2: 운영체제 DNS 설정 및 캐시**

**운영체제 DNS 설정**

```
PC 네트워크 설정:
┌──────────────┬───────────────┬───────────────┐
│ setting item │ value         │ description   │
├──────────────┼───────────────┼───────────────┤
│ IP address   │ 192.168.1.100 │ PC private IP │
│ subnet mask  │ 255.255.255.0 │ network       │
│ default GW   │ 192.168.1.1   │ 공유기 주소      │
│ DNS server 1 │ 168.126.63.1  │ KT DNS        │
│ DNS server 2 │ 168.126.63.2  │ KT DNS backup │
└──────────────┴───────────────┴───────────────┘
```

**운영체제 DNS 캐시**

```
OS DNS 캐시 테이블:
┌────────────────┬────────────────┬──────┬───────────┐
│ domain name    │ IP address     │ TTL  │ timestamp │
├────────────────┼────────────────┼──────┼───────────┤
│ www.google.com │ 142.250.191.78 │ 300s │ 10:25:30  │
│ www.naver.com  │ 223.130.195.95 │ 600s │ 10:20:15  │
│ www.my-app.com │ -              │ -    │ -         │
└────────────────┴────────────────┴──────┴───────────┘
```

**처리 과정**

1. 운영체제가 `www.my-app.com`을 로컬 캐시에서 검색
2. 캐시 미스 발생 → DNS 서버(168.126.63.1)로 질의
3. DNS 질의 패킷 생성 및 전송 준비

**쉽게 이해하기**

- 운영체제는 마치 공용 전화번호부를 확인하는 것과 같습니다
- "www.my-app.com의 번호가 있나?" 확인 후 없으면 전화번호 안내데스크에 전화를 겁니다

**처리 주체**: 운영체제 (Windows의 경우 DNS Client 서비스, Mac의 경우 mDNSResponder)

**로컬 DNS 서버 설정 확인**

- PC의 네트워크 설정에서 DNS 서버 확인
- Windows의 경우: 제어판 → 네트워크 및 인터넷 → 네트워크 연결 → 속성 → TCP/IPv4 → 속성
- Mac의 경우: 시스템 환경설정 → 네트워크 → 고급 → DNS
- 일반적으로 KT DNS: 168.126.63.1, 168.126.63.2
- 또는 Google DNS: 8.8.8.8, 8.8.4.4

**DNS 질의 패킷 생성**

```
DNS Query Packet:
- Transaction ID: 0x1234
- Flags: Standard Query (0x0100)
- Questions: 1
- Name: www.my-app.com
- Type: A (IPv4)
- Class: IN (Internet)
```

**쉽게 이해하기**

- 운영체제는 "어느 DNS 서버에 물어볼까?" 확인
- 마치 전화번호 안내데스크의 번호를 확인하는 것과 같음
- 그 다음 "www.my-app.com의 주소가 뭐야?"라는 질문을 만들어서 DNS 서버로 보냄

### 2.3 네트워크 계층에서 DNS 패킷 전송

**상태 스냅샷 #3: 네트워크 스택 패킷 생성**

**UDP 소켓 상태**

```
UDP 소켓 테이블:
┌────────────┬───────────────┬────────────┬──────────────┬─────────────┐
│ socket ID  │ local IP      │ local port │ remote IP    │ remote port │
├────────────┼───────────────┼────────────┼──────────────┼─────────────┤
│ 0x12345678 │ 192.168.1.100 │ 54321      │ 168.126.63.1 │ 53 (DNS)    │
│ 0x87654321 │ 192.168.1.100 │ 54322      │ 8.8.8.8      │ 53 (DNS)    │
└────────────┴───────────────┴────────────┴──────────────┴─────────────┘
```

**라우팅 테이블 (PC)**

```
PC 라우팅 테이블:
┌──────────────┬───────────────┬─────────────┬───────────┬────────┐
│ dest network │ subnet mask   │ gqteway     │ interface │ metric │
├──────────────┼───────────────┼─────────────┼───────────┼────────┤
│ 0.0.0.0      │ 0.0.0.0       │ 192.168.1.1 │ Wi-Fi     │ 1      │
│ 192.168.1.0  │ 255.255.255.0 │ 0.0.0.0     │ Wi-Fi     │ 1      │
│ 127.0.0.0    │ 255.0.0.0     │ 0.0.0.0     │ Loopback  │ 1      │
│ 224.0.0.0    │ 240.0.0.0     │ 0.0.0.0     │ Wi-Fi     │ 1      │
└──────────────┴───────────────┴─────────────┴───────────┴────────┘
```

**라우팅 결정 과정**

1. 목적지 IP: 168.126.63.1 (KT DNS)
2. 라우팅 테이블 검색:

- 192.168.1.0/24 네트워크에 속하지 않음
- 기본 라우트(0.0.0.0/0) 매칭
- 게이트웨이: 192.168.1.1 (공유기)

3. 결정: 공유기로 패킷 전송

**쉽게 이해하기**

- 라우팅 테이블은 마치 지도와 같습니다
- "168.126.63.1로 가려면 어느 길로 가야 할까?" 확인
- 로컬 네트워크가 아니므로 공유기(게이트웨이)를 통해 외부로 전송

**처리 주체**: 운영체제 네트워크 스택 (Windows의 경우 TCP/IP 스택, Mac의 경우 BSD 네트워크 스택)

**UDP 패킷 생성**

- 소스 포트: 54321 (동적 할당)
- 목적지 포트: 53 (DNS 표준 포트)
- 목적지 IP: 168.126.63.1 (KT DNS 서버)

**IP 패킷 상세 구조**

**IP 헤더 (20바이트)**

```
IP Header Structure:
┌─────────────────────────────────────────────────┐
│ Version │ IHL  │ Type of Service │ Total Length │
│ (4 bits)│(4)   │ (8 bits)        │ (16 bits)    │
├─────────────────────────────────────────────────┤
│ 4       │ 5    │ 0x00            │ 512          │
├─────────────────────────────────────────────────┤
│ Identification │ Flags │ Fragment Offset        │
│ (16 bits)      │ (3)   │ (13 bits)              │
├─────────────────────────────────────────────────┤
│ 0x1234         │ 0x0000│ 0                      │
├─────────────────────────────────────────────────┤
│ Time to Live   │ Protocol │ Header Checksum     │
│ (8 bits)       │ (8 bits) │ (16 bits)           │
├─────────────────────────────────────────────────┤
│ 64             │ 17 (UDP) │ 0xABCD              │
├─────────────────────────────────────────────────┤
│ Source IP Address (32 bits)                     │
├─────────────────────────────────────────────────┤
│ 192.168.001.100 (0xC0A80164)                    │
├─────────────────────────────────────────────────┤
│ Destination IP Address (32 bits)                │
├─────────────────────────────────────────────────┤
│ 168.126.063.001 (0xA87E3F01)                    │
└─────────────────────────────────────────────────┘
```

**UDP 헤더 (8바이트)**

```
UDP Header Structure:
┌────────────────────────────────┐
│ Source Port │ Destination Port │
│ (16 bits)   │ (16 bits)        │
├────────────────────────────────┤
│ 54321       │ 53 (DNS)         │
├────────────────────────────────┤
│ Length │ Checksum              │
│ (16)   │ (16 bits)             │
├────────────────────────────────┤
│ 512    │ 0xEFGH                │
└────────────────────────────────┘
```

**DNS 쿼리 페이로드 (484바이트)**

```
DNS Query Structure:
┌──────────────────────────────────────────────────┐
│ Transaction ID │ Flags  │ Questions │ Answer RRs │
│ (16 bits)      │ (16)   │ (16 bits) │ (16 bits)  │
├──────────────────────────────────────────────────┤
│ 0x1234         │ 0x0100 │ 1         │ 0          │
├──────────────────────────────────────────────────┤
│ Authority RRs  │ Additional RRs                  │
│ (16 bits)      │ (16 bits)                       │
├──────────────────────────────────────────────────┤
│ 0              │ 0                               │
├──────────────────────────────────────────────────┤
│ Query Section: www.my-app.com (A record)         │
│ - Name: www.my-app.com (variable length)         │
│ - Type: A (1)                                    │
│ - Class: IN (1)                                  │
└──────────────────────────────────────────────────┘
```

**쉽게 이해하기**

- 운영체제는 DNS 질문을 우편물로 만들어서 보내는 것과 같음
- 발신자 주소(PC IP), 수신자 주소(DNS 서버 IP), 포트 번호를 적어서 패킷을 만듦
- 마치 편지봉투에 주소를 쓰는 것과 같음

### 2.4 데이터 링크 계층에서 프레임 생성

**상태 스냅샷 #4: ARP 캐시 및 MAC 주소 확인**

**ARP 캐시 테이블 (PC)**

```
PC ARP 캐시:
┌───────────────┬───────────────────┬───────────┬───────────┐
│ IP address    │ MAC address       │ interface │ status    │
├───────────────┼───────────────────┼───────────┼───────────┤
│ 192.168.1.1   │ 00:11:22:33:44:55 │ Wi-Fi     │ REACHABLE │
│ 192.168.1.100 │ AA:BB:CC:DD:EE:FF │ Wi-Fi     │ PERMANENT │
│ 168.126.63.1  │                   │ -         │ -         │
└───────────────┴───────────────────┴───────────┴───────────┘
```

**ARP 요청 과정**

1. 목적지 IP: 192.168.1.1 (공유기)
2. ARP 캐시에서 MAC 주소 확인: 00:11:22:33:44:55 (있음)
3. ARP 요청 불필요, 캐시된 MAC 주소 사용

**이더넷 프레임 생성**

```
이더넷 프레임 구조:
┌────────────┬───────────────────┬────────┬───────────┬─────────────────┐
│ fireld     │ value             │ size   │ desc      │ reference table │
├────────────┼───────────────────┼────────┼───────────┼─────────────────┤
│ Dest MAC   │ 00:11:22:33:44:55 │ 6 byte │ 공유기 MAC  │ ARP cache       │
│ Source MAC │ AA:BB:CC:DD:EE:FF │ 6 byte │ PC MAC    │ network card    │  
│ Type       │ 0x0800            │ 2 btte │ IPv4      │ 고정값            │
│ Payload    │ IP packet         │ 가변    │ DNS query │ 네트워크 스택       │
│ FCS        │ 0x12345678        │ 4 byte │ checksum  │ 계산값            │
└────────────┴───────────────────┴────────┴───────────┴─────────────────┘
```

**쉽게 이해하기**

- ARP 캐시는 마치 개인 주소록과 같습니다
- "192.168.1.1의 실제 주소가 뭐지?" 확인
- 이미 알고 있으면 바로 사용, 모르면 물어봄

**처리 주체**: 네트워크 어댑터 드라이버 (Windows의 경우 Intel Wireless 드라이버, Mac의 경우 AirPort 드라이버)

**네트워크 장비별 처리 과정**

**로컬 PC의 역할**

- 사용자의 요청을 네트워크 패킷으로 변환
- MAC 주소와 IP 주소를 포함한 이더넷 프레임 생성
- 무선 신호로 인터넷 공유기로 전송

**인터넷 공유기의 역할**

- PC에서 전송된 무선 신호를 수신
- 패킷의 목적지 확인 (외부 네트워크로 가는지 확인)
- NAT(Network Address Translation) 수행: 사설 IP를 공인 IP로 변환
- 다음 홉(라우터)으로 패킷 전달

**스위치의 역할 (사무실 네트워크 내부)**

- MAC 주소 테이블을 기반으로 패킷 전달
- 목적지 MAC 주소가 같은 네트워크에 있으면 직접 전달
- 다른 네트워크로 가는 패킷은 라우터로 전달

**라우터의 역할**

- IP 주소를 기반으로 패킷의 최적 경로 결정
- 라우팅 테이블을 확인하여 다음 홉 결정
- 서로 다른 네트워크 간의 패킷 전달

**MAC 주소와 IP 주소의 역할 구분**

**MAC 주소를 사용하는 이유**

- MAC 주소는 물리적 네트워크 세그먼트 내에서 직접 통신을 위한 주소
- 이더넷 프레임은 MAC 주소를 기반으로 스위치나 허브에서 전송됨
- 같은 네트워크 세그먼트 내에서는 MAC 주소로 직접 통신 가능
- 라우터를 거치지 않는 로컬 네트워크에서는 MAC 주소만으로 통신

**IP 주소를 사용하는 이유**

- IP 주소는 논리적 네트워크 주소로, 다른 네트워크와의 통신을 위한 주소
- 라우터는 IP 주소를 기반으로 패킷을 다른 네트워크로 전달
- 인터넷 전체에서 유일한 주소 체계를 제공
- 네트워크 계층에서 경로 결정을 위해 사용됨

**MAC 주소 획득 방법 (ARP 프로토콜)**

**ARP (Address Resolution Protocol) 동작**

- PC가 목적지 IP 주소(168.126.63.1)에 대응하는 MAC 주소를 모를 때
- ARP 캐시 테이블 확인: `arp -a` 명령어로 확인 가능
- 캐시에 없으면 ARP 요청 브로드캐스트 전송

**ARP 요청 패킷 구조**

```
ARP Request Frame:
- Destination MAC: FF:FF:FF:FF:FF:FF (브로드캐스트)
- Source MAC: AA:BB:CC:DD:EE:FF (PC의 MAC)
- Type: 0x0806 (ARP)
- ARP Payload:
  - Hardware Type: 1 (Ethernet)
  - Protocol Type: 0x0800 (IPv4)
  - Operation: 1 (Request)
  - Sender MAC: AA:BB:CC:DD:EE:FF
  - Sender IP: 192.168.1.100
  - Target MAC: 00:00:00:00:00:00 (알 수 없음)
  - Target IP: 168.126.63.1
```

**ARP 응답 처리**

- 공유기가 ARP 응답으로 자신의 MAC 주소 전송
- PC가 ARP 캐시에 MAC 주소 저장
- 이후 통신에서는 캐시된 MAC 주소 사용

**이더넷 프레임 상세 구조**

**프레임 헤더 (14바이트)**

```
Ethernet Frame Header:
┌───────────────────┬───────────────────┬───────────┐
│ Destination MAC   │ Source MAC        │ Type      │
│ (6 bytes)         │ (6 bytes)         │ (2 bytes) │
├───────────────────┼───────────────────┼───────────┤
│ 00:11:22:33:44:55 │ AA:BB:CC:DD:EE:FF │ 0x0800    │
└───────────────────┴───────────────────┴───────────┘
```

**프레임 페이로드 (IP 패킷)**

```
IP Packet (DNS Query):
┌───────────────────────────────────┐
│ IP Header (20 bytes)              │
├───────────────────────────────────┤
│ Version: 4, Header Length: 5      │
│ Type of Service: 0x00             │
│ Total Length: 512                 │
│ Identification: 0x1234            │
│ Flags: 0x0000, Fragment Offset: 0 │
│ Time to Live: 64                  │
│ Protocol: 17 (UDP)                │
│ Header Checksum: 0xABCD           │
│ Source IP: 192.168.1.100          │
│ Destination IP: 168.126.63.1      │
├───────────────────────────────────┤
│ UDP Header (8 bytes)              │
├───────────────────────────────────┤
│ Source Port: 54321                │
│ Destination Port: 53              │
│ Length: 512                       │
│ Checksum: 0xEFGH                  │
├───────────────────────────────────┤
│ DNS Query Payload (484 bytes)     │
├───────────────────────────────────┤
│ Transaction ID: 0x1234            │
│ Flags: Standard Query (0x0100)    │
│ Questions: 1                      │
│ Answer RRs: 0                     │
│ Authority RRs: 0                  │
│ Additional RRs: 0                 │
│ Query: www.my-app.com (A record)  │
└───────────────────────────────────┘
```

**프레임 트레일러 (4바이트)**

```
Frame Trailer:
┌───────────────┐
│ FCS (4 bytes) │
│ 0x12345678    │
└───────────────┘
```

**쉽게 이해하기**

- 네트워크 카드 드라이버가 패킷을 물리적으로 전송할 수 있는 형태로 바꿈
- 마치 편지를 봉투에 넣고 우표를 붙이는 것과 같음
- MAC 주소는 실제 물리적 주소로, "이 편지를 어느 기계로 보낼까?"를 나타냄
- IP 주소는 논리적 주소로, "이 편지가 최종적으로 어느 네트워크로 가야 할까?"를 나타냄
- ARP는 마치 전화번호부에서 이름으로 번호를 찾는 것과 같음

**네트워크 장비별 쉬운 설명**

- **로컬 PC**: 마치 편지를 쓰는 사람과 같습니다. 요청을 만들어서 네트워크로 보냅니다
- **인터넷 공유기**: 마치 아파트의 우체통과 같습니다. 여러 집의 편지를 모아서 우체국으로 보냅니다
- **스위치**: 마치 건물 내부의 안내원과 같습니다. "이 편지는 어느 방으로 가야 할까?"를 결정합니다
- **라우터**: 마치 도시 간 우편물을 전달하는 우체국과 같습니다. "이 편지는 어느 도시로 가야 할까?"를 결정합니다

### 2.5 물리 계층에서 무선 신호 전송

**처리 주체**: 무선 네트워크 어댑터 하드웨어 (Intel Wireless-AC 9560, Mac의 경우 Broadcom BCM4360)

**Wi-Fi 신호 변조**

- 802.11ac 프로토콜 사용
- 채널: 6 (2.4GHz 대역)
- 변조 방식: 256-QAM
- 전송 속도: 867 Mbps
- 무선 신호를 공유기로 전송

**쉽게 이해하기**

- 무선 랜 카드가 디지털 데이터를 전자파 신호로 바꿔서 공중으로 전송
- 마치 라디오 방송국이 음악을 전자파로 바꿔서 방송하는 것과 같음
- 2.4GHz는 전자파의 주파수로, 공유기와 PC가 같은 주파수로 통신

## 3단계: 인터넷을 통한 DNS 응답

### 3.1 KT DNS 서버에서의 처리

**상태 스냅샷 #5: KT DNS 서버 내부 처리**

**KT DNS 서버 캐시**

```
KT DNS 캐시 테이블:
┌────────────────┬────────────────┬───────┬──────┬───────────┐
│ domain name    │ IP address     │ TTL   │ type │ timespamp │
├────────────────┼────────────────┼───────┼──────┼───────────┤
│ www.google.com │ 142.250.191.78 │ 300s  │ A    │ 10:25:30  │
│ www.naver.com  │ 223.130.195.95 │ 600s  │ A    │ 10:20:15  │
│ my-app.com     │ 20.123.45.67   │ 3600s │ A    │ 09:30:00  │
│ www.my-app.com │ -              │ -     │ -    │ -         │
└────────────────┴────────────────┴───────┴──────┴───────────┘
```

**DNS 서버 처리 과정**

1. 수신: `www.my-app.com` A 레코드 질의
2. 캐시 확인: `www.my-app.com` 없음, `my-app.com` 있음
3. 재귀적 질의 시작:

- Root DNS 서버에 `.com` NS 레코드 질의
- .com DNS 서버에 `my-app.com` NS 레코드 질의
- my-app.com DNS 서버에 `www.my-app.com` A 레코드 질의

**DNS 서버 라우팅 테이블**

```
KT DNS 서버 라우팅:
┌────────────────┬──────────────┬────────────────────┬───────┐
│ destination    │ server IP    │ server type        │ order │
├────────────────┼──────────────┼────────────────────┼───────┤
│ Root DNS       │ 198.41.0.4   │ a.root-servers.net │ 1     │
│ .com DNS       │ 192.5.6.30   │ a.gtld-servers.net │ 1     │
│ my-app.com DNS │ 20.123.45.67 │ Azure DNS          │ 1     │
└────────────────┴──────────────┴────────────────────┴───────┘
```

**쉽게 이해하기**

- DNS 서버는 마치 전화번호 안내데스크와 같습니다
- "www.my-app.com의 번호가 있나?" 확인 후 없으면 다른 안내데스크에 물어봄
- 최종적으로 찾은 번호를 질문한 사람에게 알려줌

**처리 주체**: KT DNS 서버 (BIND 또는 PowerDNS 소프트웨어)

**DNS 서버 수신**

- KT DNS 서버 (168.126.63.1)가 DNS 질의 수신
- DNS 캐시 확인 후 캐시 미스 시 상위 DNS 서버로 질의

**재귀적 DNS 질의**

- KT DNS → Root DNS 서버 (.) 질의
- Root DNS → .com DNS 서버 질의
- .com DNS → my-app.com DNS 서버 질의
- my-app.com DNS → www.my-app.com의 A 레코드 반환

**DNS 응답 패킷**

```
DNS Response:
- Transaction ID: 0x1234
- Flags: Response, Authoritative Answer
- Answer: www.my-app.com A 20.123.45.67
- TTL: 300 (5분)
```

**쉽게 이해하기**

- KT DNS 서버는 마치 전화번호 안내데스크와 같음
- "www.my-app.com의 주소가 뭐야?"라는 질문을 받으면
- 먼저 자체 전화번호부에서 찾아보고, 없으면 다른 안내데스크에 물어봄
- 최종적으로 찾은 주소를 질문한 사람에게 알려줌

### 3.2 응답 패킷의 역방향 전송

**상태 스냅샷 #6: 네트워크 라우터들의 라우팅 테이블**

**KT 백본 라우터 라우팅 테이블**

```
KT 백본 라우터 라우팅:
┌──────────────┬───────────────┬───────────────┬───────────┬────────┐
│ dest network │ subnet mask   │ next          │ interface │ metrix │
├──────────────┼───────────────┼───────────────┼───────────┼────────┤
│ 0.0.0.0      │ 0.0.0.0       │ 203.248.252.1 │ Internet  │ 1      │
│ 192.168.0.0  │ 255.255.0.0   │ 168.126.63.1  │ Internal  │ 1      │
│ 20.123.45.0  │ 255.255.255.0 │ 203.248.252.1 │ Internet  │ 2      │
│ 168.126.63.0 │ 255.255.255.0 │ 0.0.0.0       │ Internal  │ 1      │
└──────────────┴───────────────┴───────────────┴───────────┴────────┘
```

**KT 지역 POP 라우터 라우팅 테이블**

```
KT 지역 POP 라우터 라우팅:
┌──────────────┬───────────────┬──────────────┬───────────┬────────┐
│ dest network │ subnet mask   │ next         │ interface │ metrix │
├──────────────┼───────────────┼──────────────┼───────────┼────────┤
│ 0.0.0.0      │ 0.0.0.0       │ 168.126.63.1 │ Backbone  │ 1      │
│ 192.168.1.0  │ 255.255.255.0 │ 192.168.1.1  │ Customer  │ 1      │
│ 168.126.63.0 │ 255.255.255.0 │ 0.0.0.0      │ Backbone  │ 1      │
└──────────────┴───────────────┴──────────────┴───────────┴────────┘
```

**라우팅 결정 과정**

1. KT DNS → KT 백본: 목적지 192.168.1.100 → 기본 라우트 → 인터넷
2. KT 백본 → KT 지역 POP: 목적지 192.168.1.100 → 고객 네트워크 → 공유기
3. KT 지역 POP → 공유기: 직접 전달

**공유기 NAT 테이블**

```
공유기 NAT 테이블:
┌───────────────┬──────────────┬─────────────────┬─────────────┬─────────────┐
│ private IP    │ private port │ public IP       │ public port │ status      │
├───────────────┼──────────────┼─────────────────┼─────────────┼─────────────┤
│ 192.168.1.100 │ 54321        │ 203.248.252.100 │ 12345       │ ESTABLISHED │
│ 192.168.1.101 │ 54322        │ 203.248.252.100 │ 12346       │ ESTABLISHED │
└───────────────┴──────────────┴─────────────────┴─────────────┴─────────────┘
```

**쉽게 이해하기**

- 라우터들은 마치 우체국 체인과 같습니다
- 각 우체국이 "이 편지를 어느 방향으로 보낼까?" 결정
- NAT 테이블은 마치 아파트 우체통의 주소 변환표와 같습니다

**처리 주체**: 네트워크 라우터들 (KT 백본 라우터, 지역 POP 라우터, 사용자 공유기)

**네트워크 장비별 역방향 처리**

**라우터의 역방향 처리**

- DNS 서버에서 온 응답 패킷을 수신
- 라우팅 테이블을 확인하여 사용자 네트워크로 전달
- 각 라우터가 "이 응답을 어느 방향으로 보낼까?" 결정

**인터넷 공유기의 역방향 처리**

- 라우터에서 온 응답 패킷을 수신
- NAT 테이블을 확인하여 원래 요청한 PC로 전달
- 사설 IP 주소로 변환하여 로컬 네트워크로 전송

**스위치의 역방향 처리**

- 공유기에서 온 응답 패킷을 수신
- MAC 주소 테이블을 확인하여 해당 PC로 전달
- "이 응답은 어느 PC로 가야 할까?" 결정

**로컬 PC의 역방향 처리**

- 스위치에서 온 응답 패킷을 수신
- 네트워크 스택에서 패킷 처리
- 브라우저에 IP 주소 (20.123.45.67) 전달

**네트워크 경로**

- KT DNS 서버 → KT 백본 네트워크 → KT 지역 POP → 사용자 공유기
- 각 홉에서 라우팅 테이블 확인 후 다음 홉으로 전송

**패킷 수신**

- PC가 DNS 응답 패킷 수신
- 브라우저에 IP 주소 (20.123.45.67) 전달

**쉽게 이해하기**

- DNS 서버가 찾은 주소를 다시 PC로 보내는 과정
- 마치 우편물이 여러 우체국을 거쳐서 발신자에게 돌아오는 것과 같음
- 각 라우터는 "이 편지를 어느 방향으로 보낼까?"를 결정하는 역할

**네트워크 장비별 쉬운 설명**

- **라우터**: 마치 우체국에서 "이 편지를 어느 방향으로 보낼까?" 결정하는 것과 같습니다
- **인터넷 공유기**: 마치 아파트 우체통에서 "이 편지는 어느 집으로 가야 할까?" 확인하는 것과 같습니다
- **스위치**: 마치 건물 안내원이 "이 편지는 어느 방으로 가야 할까?" 결정하는 것과 같습니다
- **로컬 PC**: 마치 편지를 받는 사람이 봉투를 뜯고 내용을 확인하는 것과 같습니다

## 4단계: TCP 연결 수립

### 4.1 TCP 3-way 핸드셰이크

**상태 스냅샷 #7: TCP 연결 상태 및 소켓 테이블**

**TCP 소켓 상태 (연결 전)**

```
PC TCP 소켓 테이블 (연결 전):
┌────────────┬───────────────┬────────────┬──────────────┬─────────────┬────────┐
│ socket ID  │ local IP      │ local port │ remote IP    │ remote poer │ status │
├────────────┼───────────────┼────────────┼──────────────┼─────────────┼────────┤
│ 0x12345678 │ 192.168.1.100 │ 54321      │ 168.126.63.1 │ 53 (DNS)    │ CLOSED │
│ 0x87654321 │ 192.168.1.100 │ 54322      │ 8.8.8.8      │ 53 (DNS)    │ CLOSED │
└────────────┴───────────────┴────────────┴──────────────┴─────────────┴────────┘
```

**TCP 연결 상태 머신**

```
TCP 상태 전이:
┌───────────────┬─────────────────┬─────────────┬───────────────┬──────────────────┐
│ current satus │ event           │ next status │ action        │ reference table  │
├───────────────┼─────────────────┼─────────────┼───────────────┼──────────────────┤
│ CLOSED        │ connect()       │ SYN_SENT    │ SYN transfer  │ socket table     │
│ SYN_SENT      │ receive SYN+ACK │ ESTABLISHED │ ACK transfer  │ connection table │
│ ESTABLISHED   │ data transfer   │ ESTABLISHED │ data transfer │ data buffer      │
└───────────────┴─────────────────┴─────────────┴───────────────┴──────────────────┘
```

**TCP 연결 테이블 (연결 후)**

```
PC TCP 연결 테이블 (연결 후):
┌────────────┬───────────────┬────────────┬──────────────┬─────────────┬─────────────┐
│ socket ID  │ local IP      │ local port │ remote IP    │ remote port │ status      │
├────────────┼───────────────┼────────────┼──────────────┼─────────────┼─────────────┤
│ 0x12345678 │ 192.168.1.100 │ 54321      │ 168.126.63.1 │ 53 (DNS)    │ CLOSED      │
│ 0x87654321 │ 192.168.1.100 │ 54322      │ 8.8.8.8      │ 53 (DNS)    │ CLOSED      │
│ 0xABCD1234 │ 192.168.1.100 │ 54323      │ 20.123.45.67 │ 443 (HTTPS) │ ESTABLISHED │
└────────────┴───────────────┴────────────┴──────────────┴─────────────┴─────────────┘
```

**쉽게 이해하기**

- TCP 소켓 테이블은 마치 전화번호부와 같습니다
- "어느 번호로 연결했는지" 기록하고 상태를 추적합니다
- ESTABLISHED는 "통화 중" 상태와 같습니다

**처리 주체**: 운영체제 TCP/IP 스택 (Windows의 경우 TCP/IP 드라이버, Mac의 경우 BSD TCP 스택)

**TCP 패킷 상세 구조**

**TCP 헤더 (20바이트)**

```
TCP Header Structure:
┌──────────────────────────────────────────────┐
│ Source Port │ Destination Port               │
│ (16 bits)   │ (16 bits)                      │
├──────────────────────────────────────────────┤
│ 54322       │ 443 (HTTPS)                    │
├──────────────────────────────────────────────┤
│ Sequence Number (32 bits)                    │
├──────────────────────────────────────────────┤
│ 1234567890                                   │
├──────────────────────────────────────────────┤
│ Acknowledgment Number (32 bits)              │
├──────────────────────────────────────────────┤
│ 0 (SYN 패킷에서는 0)                            │
├──────────────────────────────────────────────┤
│ Data Offset │ Reserved │ Flags │ Window Size │
│ (4 bits)    │ (3 bits) │ (9)   │ (16 bits)   │
├──────────────────────────────────────────────┤
│ 5           │ 000      │ SYN   │ 65535       │
├──────────────────────────────────────────────┤
│ Checksum │ Urgent Pointer                    │
│ (16 bits) │ (16 bits)                        │
├──────────────────────────────────────────────┤
│ 0xABCD   │ 0                                 │
└──────────────────────────────────────────────┘
```

**TCP 플래그 상세 설명**

```
TCP Flags (9 bits):
┌───────────────────────────────────────────────┐
│ CWR │ ECE │ URG │ ACK │ PSH │ RST │ SYN │ FIN │
│ (1) │ (1) │ (1) │ (1) │ (1) │ (1) │ (1) │ (1) │
├───────────────────────────────────────────────┤
│ 0   │ 0   │ 0   │ 0   │ 0   │ 0   │ 1   │ 0   │
└───────────────────────────────────────────────┘
- SYN: 연결 시작 요청
- ACK: 확인 응답
- FIN: 연결 종료 요청
- RST: 연결 재설정
- PSH: 데이터 즉시 전송
- URG: 긴급 데이터
```

**SYN 패킷 전송**

**SYN-ACK 응답**

- Azure Load Balancer가 SYN-ACK 응답
- Sequence Number: 9876543210
- Acknowledgment Number: 1234567891

**ACK 패킷 전송**

- PC가 ACK 패킷 전송으로 연결 완료
- 양방향 통신 채널 확립

**쉽게 이해하기**

- TCP 연결은 마치 전화를 거는 과정과 같음
- PC가 "여보세요?" (SYN) → 서버가 "네, 여보세요" (SYN-ACK) → PC가 "연결됐네요" (ACK)
- 이 과정을 통해 양쪽이 서로 통신할 준비가 되었음을 확인

### 4.2 TLS 핸드셰이크

**처리 주체**: 브라우저 TLS 라이브러리 (Chrome의 경우 BoringSSL, Safari의 경우 SecureTransport)

**ClientHello 전송**

```
TLS ClientHello:
- TLS Version: 1.3
- Random: 32바이트 랜덤 값
- Cipher Suites: TLS_AES_256_GCM_SHA384, ...
- Extensions: Server Name Indication (SNI)
```

**ServerHello 응답**

- Azure Load Balancer가 ServerHello 응답
- 선택된 암호화 스위트: TLS_AES_256_GCM_SHA384
- 서버 랜덤 값 전송

**키 교환 및 암호화 시작**

- ECDHE 키 교환 수행
- 공유 비밀키 생성
- 이후 모든 통신 암호화

**쉽게 이해하기**

- TLS는 마치 비밀 대화를 위한 암호를 정하는 과정과 같음
- 브라우저가 "이런 방식으로 암호화할 수 있어요" (ClientHello)
- 서버가 "좋아요, 이 방식으로 하죠" (ServerHello)
- 양쪽이 비밀키를 만들어서 앞으로의 대화를 암호화

## 5단계: Azure 클라우드 내부 라우팅

### 5.1 Azure Load Balancer 처리

**상태 스냅샷 #8: Azure Load Balancer 내부 상태**

**Azure Load Balancer 백엔드 풀**

```
Azure Load Balancer 백엔드 풀:
┌──────────────┬────────────┬──────┬───────────┬──────────────┐
│ Backend ID   │ IP address │ port │ status    │ health check │
├──────────────┼────────────┼──────┼───────────┼──────────────┤
│ aks-node-001 │ 10.0.1.5   │ 80   │ Healthy   │ 200 OK       │
│ aks-node-002 │ 10.0.1.6   │ 80   │ Healthy   │ 200 OK       │
│ aks-node-003 │ 10.0.1.7   │ 80   │ Unhealthy │ Timeout      │
│ aks-node-004 │ 10.0.1.8   │ 80   │ Healthy   │ 200 OK       │
└──────────────┴────────────┴──────┴───────────┴──────────────┘
```

**Load Balancer 연결 풀**

```
Azure Load Balancer 연결 풀:
┌─────────────────┬─────────────┬────────────┬──────────────┬──────────────────┐
│ client IP       │ client port │ backend IP │ backend port │ connection time  │
├─────────────────┼─────────────┼────────────┼──────────────┼──────────────────┤
│ 203.248.252.100 │ 54323       │ 10.0.1.5   │ 80           │ 10:30:45         │
│ 203.248.252.101 │ 54324       │ 10.0.1.6   │ 80           │ 10:30:46         │
│ 203.248.252.102 │ 54325       │ 10.0.1.8   │ 80           │ 10:30:47         │
└─────────────────┴─────────────┴────────────┴──────────────┴──────────────────┘
```

**로드 밸런싱 알고리즘**

```
라운드 로빈 알고리즘:
┌─────────────┬──────────────────┬────────┬─────────────────┐
│ request     │ selected backend │ reason │ reference table │
├─────────────┼──────────────────┼────────┼─────────────────┤
│ 1st request │ 10.0.1.5         │ 첫 번째  │ backend pool    │
│ 2nd request │ 10.0.1.6         │ 두 번째  │ backend pool    │
│ 3rd request │ 10.0.1.8         │ 네 번째  │ backend pool    │
│ 4th request │ 10.0.1.5         │ 순환    │ backend pool    │
└─────────────┴──────────────────┴────────┴─────────────────┘
```

**쉽게 이해하기**

- Load Balancer는 마치 건물 안내 데스크와 같습니다
- "어느 층으로 안내할까?" 결정하고 방문자 정보를 기록합니다
- 헬스 체크는 마치 "각 층이 정상적으로 작동하나?" 확인하는 것과 같습니다

**처리 주체**: Azure Load Balancer (Microsoft의 소프트웨어 정의 네트워킹)

**Azure Load Balancer 수신**

- 공인 IP: 20.123.45.67
- Load Balancer가 요청을 AKS 클러스터로 전달
- 헬스 체크를 통한 백엔드 풀 상태 확인

**로드 밸런싱 알고리즘**

- 라운드 로빈 방식으로 AKS 노드 선택
- 선택된 노드: aks-nodepool1-12345678-vmss000001

**쉽게 이해하기**

- Azure Load Balancer는 마치 건물의 안내 데스크와 같음
- 방문자가 들어오면 "어느 층으로 안내할까?" 결정
- 여러 서버 중에서 한 대를 선택해서 요청을 전달
- 각 서버가 건강한지(헬스 체크)도 계속 확인

### 5.2 Azure Virtual Network 라우팅

**처리 주체**: Azure Virtual Network (Microsoft의 가상 네트워크 인프라)

**네트워크 보안 그룹 (NSG) 검사**

- 인바운드 규칙 확인: 포트 443 허용
- 아웃바운드 규칙 확인: 모든 트래픽 허용

**서브넷 라우팅**

- AKS 서브넷: 10.0.1.0/24
- 선택된 노드 IP: 10.0.1.5

**쉽게 이해하기**

- Azure Virtual Network는 마치 회사 건물의 보안 시스템과 같음
- 출입문에서 "이 사람이 들어와도 될까?" 확인 (NSG)
- 건물 내부에서 "어느 층으로 가야 할까?" 결정 (서브넷 라우팅)
- 마치 회사 건물에서 방문증을 확인하고 적절한 층으로 안내하는 것과 같음

## 6단계: AKS 클러스터 내부 처리

### 6.1 AKS 노드 수신

**상태 스냅샷 #9: kube-proxy 및 iptables 규칙**

**kube-proxy Service 테이블**

```
kube-proxy Service 테이블:
┌─────────────────┬─────────────┬──────┬───────────┬────────────────┐
│ Service name    │ ClusterIP   │ port │ type      │ Endpoint count │
├─────────────────┼─────────────┼──────┼───────────┼────────────────┤
│ my-app-frontend │ 10.96.1.100 │ 80   │ ClusterIP │ 3              │
│ my-app-backend  │ 10.96.2.100 │ 8080 │ ClusterIP │ 2              │
│ kube-dns        │ 10.96.0.10  │ 53   │ ClusterIP │ 2              │
└─────────────────┴─────────────┴──────┴───────────┴────────────────┘
```

**kube-proxy Endpoint 테이블**

```
my-app-frontend Endpoints:
┌────────────────┬────────────┬──────┬────────┬───────────────┐
│ Pod name       │ Pod IP     │ port │ status │ selected rate │
├────────────────┼────────────┼──────┼────────┼───────────────┤
│ frontend-pod-1 │ 10.244.1.5 │ 80   │ Ready  │ 33.3%         │
│ frontend-pod-2 │ 10.244.1.6 │ 80   │ Ready  │ 33.3%         │
│ frontend-pod-3 │ 10.244.1.7 │ 80   │ Ready  │ 33.3%         │
└────────────────┴────────────┴──────┴────────┴───────────────┘
```

**iptables 규칙 (NAT 테이블)**

```
iptables -t nat -L PREROUTING:
┌───────────────┬───────────────┬────────────┬─────────────────┬─────────────┐
│ chain         │ targt         │ protofoenl │ match condition │ action      │
├───────────────┼───────────────┼────────────┼─────────────────┼─────────────┤
│ PREROUTING    │ KUBE-SERVICES │ all        │ 10.96.0.0/16    │ Service 조회  │
│ KUBE-SERVICES │ KUBE-SVC-XXX  │ tcp        │ 10.96.1.100:80  │ Load Balance │
│ KUBE-SVC-XXX  │ KUBE-SEP-YYY  │ tcp        │ random          │ Endpoint 선택 │
│ KUBE-SEP-YYY  │ DNAT          │ tcp        │ 10.244.1.5:80   │ 포트 변환      │
└───────────────┴───────────────┴────────────┴─────────────────┴──────────────┘
```

**실제 iptables 명령어**

```bash
# Service 규칙
iptables -t nat -A PREROUTING -d 10.96.1.100/32 -p tcp --dport 80 -j KUBE-SERVICES
iptables -t nat -A KUBE-SERVICES -d 10.96.1.100/32 -p tcp --dport 80 -j KUBE-SVC-XXX

# Load Balancing 규칙
iptables -t nat -A KUBE-SVC-XXX -m statistic --mode random --probability 0.3333333333 -j KUBE-SEP-YYY
iptables -t nat -A KUBE-SVC-XXX -m statistic --mode random --probability 0.5000000000 -j KUBE-SEP-ZZZ
iptables -t nat -A KUBE-SVC-XXX -j KUBE-SEP-WWW

# DNAT 규칙
iptables -t nat -A KUBE-SEP-YYY -p tcp -j DNAT --to-destination 10.244.1.5:80
```

**쉽게 이해하기**

- kube-proxy는 마치 건물 내부의 안내 시스템과 같습니다
- Service는 마치 "어느 부서로 가야 할까?"를 결정하는 것과 같습니다
- iptables는 마치 건물 내부의 길 안내 표지판과 같습니다
- "이 방향으로 가면 어느 방에 도착한다"는 규칙을 만들어둡니다

**처리 주체**: kube-proxy (쿠버네티스의 네트워크 프록시 컴포넌트)

**kube-proxy 처리**

- 노드의 kube-proxy가 Service 규칙 확인
- Service: my-app-frontend
- ClusterIP: 10.96.1.100
- 포트 매핑: 80 → 8080

**iptables 규칙 적용**

```
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 10.244.1.5:8080
```

**쉽게 이해하기**

- kube-proxy는 마치 건물 내부의 안내원과 같음
- "어느 방으로 가야 할까?"를 결정하고 안내
- iptables는 마치 건물 내부의 길 안내 표지판과 같음
- "이 방향으로 가면 어느 방에 도착한다"는 규칙을 만들어둠

### 6.2 Pod 선택 및 라우팅

**처리 주체**: 쿠버네티스 Service (kube-proxy와 함께 동작)

**Service Endpoint 선택**

- Service가 관리하는 Endpoint 목록 확인
- 선택된 Pod: my-app-frontend-abc123def456
- Pod IP: 10.244.1.5

**네트워크 정책 검사**

- NetworkPolicy 규칙 확인
- 인그레스 트래픽 허용 규칙 적용

**쉽게 이해하기**

- Service는 마치 건물 내부의 방 목록과 같음
- "어느 방에 손님이 들어와도 될까?" 확인 (NetworkPolicy)
- 여러 방 중에서 한 방을 선택해서 안내

## 7단계: 프론트엔드 Pod 처리

### 7.1 Nginx 컨테이너 수신

**상태 스냅샷 #10: Nginx 내부 상태 및 설정**

**Nginx 프로세스 상태**

```
Nginx 프로세스 테이블:
┌────────────┬────────┬─────────┬──────────────────┬──────────────┐
│ process ID │ type   │ status  │ connection count │ memory usage │
├────────────┼────────┼─────────┼──────────────────┼──────────────┤
│ 1          │ Master │ Running │ -                │ 2MB          │
│ 10         │ Worker │ Running │ 5                │ 15MB         │
│ 11         │ Worker │ Running │ 3                │ 12MB         │
│ 12         │ Worker │ Running │ 7                │ 18MB         │
└────────────┴────────┴─────────┴──────────────────┴──────────────┘
```

**Nginx 설정 파일 (nginx.conf)**

```
Nginx 설정 구조:
┌──────────┬───────────────┬────────────────┬───────────┐
│ bloclk   │ setting       │ value          │ reference │
├──────────┼───────────────┼────────────────┼───────────┤
│ http     │ server_tokens │ off            │ 보안       │
│ http     │ gzip          │ on             │ 압축       │
│ server   │ listen        │ 80             │ 포트       │
│ server   │ server_name   │ my-app.com     │ 도메인      │
│ location │ /my-app/      │ proxy_pass     │ 백엔드      │
│ location │ proxy_pass    │ my-app-backend │ 서비스명    │
└──────────┴───────────────┴────────────────┴───────────┘
```

**Nginx 연결 풀**

```
Nginx 연결 테이블:
┌───────────────┬─────────────────┬────────────────┬─────────────┬─────────────────┐
│ connection ID │ client IP       │ request URI    │ tatus       │ processing time │
├───────────────┼─────────────────┼────────────────┼─────────────┼─────────────────┤
│ 1001          │ 203.248.252.100 │ /my-app/data   │ Processing  │ 10:30:45        │
│ 1002          │ 203.248.252.101 │ /my-app/status │ Established │ 10:30:46        │
│ 1003          │ 203.248.252.102 │ /my-app/config │ Established │ 10:30:47        │
└───────────────┴─────────────────┴────────────────┴─────────────┴─────────────────┘
```

**Nginx 로그 엔트리**

```
Nginx 액세스 로그:
┌───────────┬─────────────────┬────────────────────┬────────┬───────────────┐
│ timestamp │ client IP       │ request            │ status │ response size │
├───────────┼─────────────────┼────────────────────┼────────┼───────────────┤
│ 10:30:45  │ 203.248.252.100 │ GET /my-app/data   │ 200    │ 1234          │
│ 10:30:46  │ 203.248.252.101 │ GET /my-app/status │ 200    │ 567           │
│ 10:30:47  │ 203.248.252.102 │ GET /my-app/config │ 200    │ 890           │
└───────────┴─────────────────┴────────────────────┴────────┴───────────────┘
```

**쉽게 이해하기**

- Nginx는 마치 건물의 안내 데스크와 같습니다
- "어떤 업무를 보러 오셨나요?" 확인하고 적절한 부서로 안내합니다
- 로그는 마치 방문자 명부와 같아서 "누가 언제 왔는지" 기록합니다

**처리 주체**: Nginx 웹서버 (Docker 컨테이너 내부에서 실행)

**Nginx 프로세스 처리**

- Nginx 워커 프로세스가 요청 수신
- 요청 로그 기록:

```
192.168.1.100 - - [15/Dec/2023:10:30:45 +0900] "GET /my-app/data HTTP/1.1" 200 1234
```

**Nginx 설정 확인**

- location 블록 매칭: `/my-app/`
- proxy_pass 설정: `http://my-app-backend:8080`
- 헤더 수정: Host, X-Real-IP, X-Forwarded-For

**쉽게 이해하기**

- Nginx는 마치 건물의 안내 데스크와 같음
- 방문자가 들어오면 "어떤 업무를 보러 오셨나요?" 확인
- 그 업무를 처리할 수 있는 다른 부서로 안내
- 방문자의 정보(IP, 프로토콜 등)를 기록해서 전달

### 7.2 백엔드 Service로 프록시

**처리 주체**: Nginx 프록시 모듈 + kube-dns

**내부 DNS 질의**

- Nginx가 `my-app-backend` 서비스명으로 DNS 질의
- kube-dns가 응답: 10.96.2.100

**프록시 요청 생성**

```
GET /my-app/data HTTP/1.1
Host: my-app-backend:8080
X-Real-IP: 192.168.1.100
X-Forwarded-For: 192.168.1.100
X-Forwarded-Proto: https
```

**쉽게 이해하기**

- Nginx가 "백엔드 부서는 어디에 있나요?"라고 내부 안내데스크에 물어봄
- 안내데스크가 "10.96.2.100에 있습니다"라고 알려줌
- Nginx가 방문자의 정보를 담은 메모와 함께 백엔드 부서로 전달

## 8단계: 백엔드 Pod 처리

### 8.1 Spring Boot 애플리케이션 수신

**상태 스냅샷 #11: Spring Boot 내부 상태**

**JVM 스레드 풀 상태**

```
Spring Boot 스레드 풀:
┌───────────┬──────────────────────┬──────────┬──────────────────┬────────────────┐
│ thread ID │ name                 │ status   │ request          │ start datetime │
├───────────┼──────────────────────┼──────────┼──────────────────┼────────────────┤
│ 1         │ main                 │ RUNNABLE │ -                │ 10:00:00       │
│ 10        │ http-nio-8080-exec-1 │ RUNNABLE │ GET /my-app/data │ 10:30:45       │
│ 11        │ http-nio-8080-exec-2 │ WAITING  │ -                │ 10:30:46       │
│ 12        │ http-nio-8080-exec-3 │ WAITING  │ -                │ 10:30:47       │
└───────────┴──────────────────────┴──────────┴──────────────────┴────────────────┘
```

**Spring MVC URL 매핑 테이블**

```
DispatcherServlet URL 매핑:
┌────────────────┬─────────────┬──────────────────┬─────────────┬───────┐
│ URL pattern    │ HTTP method │ controller       │ method      │ order │
├────────────────┼─────────────┼──────────────────┼─────────────┼───────┤
│ /my-app/data   │ GET         │ DataController   │ getData()   │ 1     │
│ /my-app/status │ GET         │ StatusController │ getStatus() │ 1     │
│ /my-app/config │ GET         │ ConfigController │ getConfig() │ 1     │
│ /health        │ GET         │ HealthController │ getHealth() │ 2     │
└────────────────┴─────────────┴──────────────────┴─────────────┴───────┘
```

**Spring Boot 요청 처리 상태**

```
요청 처리 상태:
┌────────────┬────────────┬────────────────────┬──────────────────────┬──────────┐
│ request ID │ client IP  │ request URI        │ process step         │ duration │
├────────────┼────────────┼────────────────────┼──────────────────────┼──────────┤
│ req-001    │ 10.244.1.5 │ GET /my-app/data   │ controller execution │ 50ms     │
│ req-002    │ 10.244.1.6 │ GET /my-app/status │ service call         │ 30ms     │
│ req-003    │ 10.244.1.7 │ GET /my-app/config │ DB query             │ 100ms    │
└────────────┴────────────┴────────────────────┴──────────────────────┴──────────┘
```

**Spring Boot 로그 엔트리**

```
Spring Boot 애플리케이션 로그:
┌──────────────┬───────────┬────────────────┬───────────────────────────────────┬────────────┐
│ timestamp    │ log level │ class          │ message                           │ request ID │
├──────────────┼───────────┼────────────────┼───────────────────────────────────┼────────────┤
│ 10:30:45.123 │ INFO      │ DataController │ GET /my-app/data request received │ req-001    │
│ 10:30:45.150 │ DEBUG     │ DataService    │ database query start              │ req-001    │
│ 10:30:45.200 │ INFO      │ DataController │ generate response complete        │ req-001    │
└──────────────┴───────────┴────────────────┴───────────────────────────────────┴────────────┘
```

**쉽게 이해하기**

- Spring Boot는 마치 실제 업무를 처리하는 부서와 같습니다
- DispatcherServlet은 마치 부서의 안내원으로, "어떤 업무인가요?" 확인합니다
- 스레드 풀은 마치 여러 직원이 동시에 업무를 처리하는 것과 같습니다
- 로그는 마치 업무 일지와 같아서 "어떤 업무를 언제 처리했는지" 기록합니다

**처리 주체**: Spring Boot 애플리케이션 (JVM 내부에서 실행)

**Spring Boot 내부 처리**

- DispatcherServlet이 요청 수신
- URL 매핑: `/my-app/data` → `DataController.getData()`
- 요청 로그 기록:

```
2023-12-15 10:30:45.123 INFO  [http-nio-8080-exec-1] c.e.m.DataController - GET /my-app/data 요청 수신
```

**컨트롤러 메서드 실행**

```java

@GetMapping("/my-app/data")
public ResponseEntity<DataResponse> getData() {
  // 비즈니스 로직 실행
  DataService dataService = applicationContext.getBean(DataService.class);
  List<Data> dataList = dataService.getData();

  // 응답 생성
  DataResponse response = new DataResponse(dataList);
  return ResponseEntity.ok(response);
}
```

**쉽게 이해하기**

- Spring Boot는 마치 실제 업무를 처리하는 부서와 같음
- DispatcherServlet은 마치 부서의 안내원으로, "어떤 업무인가요?" 확인
- 컨트롤러는 마치 실제 업무를 담당하는 직원으로, 요청에 따라 데이터를 조회하고 응답

### 8.2 데이터베이스 조회

**처리 주체**: JPA/Hibernate (Spring Boot 애플리케이션 내부)

**JPA/Hibernate 처리**

- EntityManager가 데이터베이스 연결 확인
- SQL 쿼리 생성:

```sql
SELECT d.id, d.name, d.value, d.created_at
FROM data d
WHERE d.status = 'ACTIVE'
ORDER BY d.created_at DESC
```

**데이터베이스 응답 처리**

- ResultSet을 Entity 객체로 변환
- JSON 직렬화 준비

**쉽게 이해하기**

- JPA/Hibernate는 마치 데이터베이스와 대화하는 통역사와 같음
- Java 객체를 SQL 언어로 바꿔서 데이터베이스에 질문
- 데이터베이스가 답변한 결과를 다시 Java 객체로 바꿔서 애플리케이션에 전달

### 8.3 응답 생성

**처리 주체**: Spring Boot HTTP 응답 생성기

**JSON 응답 생성**

```json
{
  "status": "success",
  "data": [
    {
      "id": 1,
      "name": "Sample Data 1",
      "value": "Value 1",
      "createdAt": "2023-12-15T10:30:45Z"
    },
    {
      "id": 2,
      "name": "Sample Data 2",
      "value": "Value 2",
      "createdAt": "2023-12-15T10:29:30Z"
    }
  ],
  "timestamp": "2023-12-15T10:30:45.123Z"
}
```

**HTTP 응답 헤더 설정**

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Content-Length: 456
Date: Fri, 15 Dec 2023 01:30:45 GMT
Server: Spring Boot/2.7.0
```

**쉽게 이해하기**

- Spring Boot가 조회한 데이터를 브라우저가 이해할 수 있는 JSON 형태로 변환
- 마치 업무 결과를 정리해서 보고서로 만드는 것과 같음
- HTTP 헤더는 마치 보고서의 제목과 작성일, 페이지 수 등을 적는 것과 같음

## 9단계: 응답 전송 과정

### 9.1 백엔드에서 프론트엔드로 응답

**처리 주체**: Spring Boot HTTP 응답 전송기 + Nginx 프록시

**Spring Boot 응답 전송**

- HttpServletResponse에 JSON 데이터 쓰기
- 응답 스트림 플러시
- TCP 소켓을 통한 응답 전송

**Nginx 프록시 응답 처리**

- 백엔드 응답을 받아서 버퍼링
- 응답 헤더 수정:

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Content-Length: 456
Date: Fri, 15 Dec 2023 01:30:45 GMT
Server: nginx/1.18.0
X-Powered-By: Spring Boot
```

**쉽게 이해하기**

- Spring Boot가 완성한 보고서를 Nginx에게 전달
- Nginx가 보고서를 받아서 "이 보고서는 우리 회사에서 만들었습니다"라고 표시 추가
- 마치 부서에서 완성한 보고서를 안내 데스크가 받아서 회사 로고를 찍고 방문자에게 전달하는 것과 같음

### 9.2 AKS 클러스터를 통한 응답 전송

**처리 주체**: kube-proxy + Azure Load Balancer

**Service를 통한 응답 라우팅**

- kube-proxy가 응답을 원본 요청자로 라우팅
- iptables 규칙을 통한 NAT 처리

**Load Balancer 응답 처리**

- Azure Load Balancer가 응답을 클라이언트로 전송
- 연결 풀에서 해당 TCP 연결 찾아서 응답

**쉽게 이해하기**

- kube-proxy가 "이 응답을 어디로 보낼까?" 확인하고 안내
- Azure Load Balancer가 "이 응답을 건물 밖으로 내보내야겠다" 결정
- 마치 안내 데스크가 방문자에게 완성된 보고서를 전달하는 것과 같음

### 9.3 인터넷을 통한 응답 전송

**처리 주체**: 네트워크 라우터들 + 무선 네트워크 어댑터

**네트워크 장비별 응답 전송**

**Azure Load Balancer의 응답 전송**

- Spring Boot 서버에서 온 응답을 수신
- 원본 요청자의 IP 주소로 응답 전송
- 연결 풀에서 해당 TCP 연결 찾아서 응답

**라우터들의 응답 전송**

- Azure 백본 네트워크의 라우터들이 응답을 인터넷으로 전달
- 각 라우터가 라우팅 테이블을 확인하여 최적 경로 선택
- KT 백본 네트워크로 응답 전달

**인터넷 공유기의 응답 수신**

- KT 지역 POP에서 온 응답을 수신
- NAT 테이블을 확인하여 원래 요청한 PC로 전달
- 로컬 네트워크로 응답 전송

**스위치의 응답 전달**

- 공유기에서 온 응답을 수신
- MAC 주소 테이블을 확인하여 해당 PC로 전달
- "이 응답은 어느 PC로 가야 할까?" 결정

**로컬 PC의 응답 수신**

- 스위치에서 온 응답을 수신
- 무선 네트워크 어댑터가 802.11ac 신호를 디지털 데이터로 변환
- 네트워크 스택에서 패킷 처리 및 브라우저로 전달

**네트워크 홉별 전송**

- Azure 데이터센터 → Azure 백본 네트워크 → 인터넷 익스체인지
- KT 백본 네트워크 → KT 지역 POP → 사용자 공유기

**무선 네트워크를 통한 최종 전송**

- 802.11ac 무선 신호로 PC에 응답 전송
- TCP ACK 패킷으로 연결 상태 확인

**쉽게 이해하기**

- 응답이 여러 우체국을 거쳐서 발신자에게 돌아오는 과정
- 마치 택배가 여러 물류센터를 거쳐서 수신자에게 도착하는 것과 같음
- 무선 신호는 마치 라디오 방송이 수신자에게 도달하는 것과 같음

**네트워크 장비별 쉬운 설명**

- **Azure Load Balancer**: 마치 건물 안내 데스크가 방문자에게 완성된 보고서를 전달하는 것과 같습니다
- **라우터들**: 마치 여러 우체국이 편지를 순서대로 전달하는 것과 같습니다
- **인터넷 공유기**: 마치 아파트 우체통에서 "이 편지는 어느 집으로 가야 할까?" 확인하는 것과 같습니다
- **스위치**: 마치 건물 안내원이 "이 편지는 어느 방으로 가야 할까?" 결정하는 것과 같습니다
- **로컬 PC**: 마치 편지를 받는 사람이 봉투를 뜯고 내용을 확인하는 것과 같습니다

## 10단계: 브라우저에서 응답 처리

### 10.1 브라우저 수신 처리

**상태 스냅샷 #12: 브라우저 내부 상태**

**브라우저 네트워크 스택 상태**

```
브라우저 네트워크 연결 테이블:
┌───────────────┬────────────────┬─────────────┬──────────┬─────────────┐
│ connection ID │ remote IP      │ remote port │ protocol │ status      │
├───────────────┼────────────────┼─────────────┼──────────┼─────────────┤
│ conn-001      │ 20.123.45.67   │ 443         │ HTTPS    │ ESTABLISHED │
│ conn-002      │ 142.250.191.78 │ 443         │ HTTPS    │ ESTABLISHED │
│ conn-003      │ 223.130.195.95 │ 443         │ HTTPS    │ ESTABLISHED │
└───────────────┴────────────────┴─────────────┴──────────┴─────────────┘
```

**브라우저 TLS 세션 테이블**

```
브라우저 TLS 세션:
┌────────────────┬─────────────┬──────────────────────────────┬────────────┬─────────────────┐
│ server domain  │ TLS version │ Cipher Suite                 │ session ID │ expiration time │
├────────────────┼─────────────┼──────────────────────────────┼────────────┼─────────────────┤
│ www.my-app.com │ TLS 1.3     │ TLS_AES_256_GCM_SHA384       │ 0x1234     │ 10:35:45        │
│ www.google.com │ TLS 1.3     │ TLS_CHACHA20_POLY1305_SHA256 │ 0x5678     │ 10:40:00        │
└────────────────┴─────────────┴──────────────────────────────┴────────────┴─────────────────┘
```

**브라우저 HTTP 캐시**

```
브라우저 HTTP 캐시:
┌────────────────┬─────────────┬─────────────┬──────────────┬─────────────────┐
│ URL            │ HTTP method │ status code │ cache policy │ expiration time │
├────────────────┼─────────────┼─────────────┼──────────────┼─────────────────┤
│ /my-app/data   │ GET         │ 200         │ no-cache     │ -               │
│ /my-app/status │ GET         │ 200         │ max-age=300  │ 10:35:45        │
│ /my-app/config │ GET         │ 200         │ max-age=600  │ 10:40:45        │
└────────────────┴─────────────┴─────────────┴──────────────┴─────────────────┘
```

**브라우저 JavaScript 실행 상태**

```
JavaScript 실행 컨텍스트:
┌────────────┬───────────────┬──────────┬──────────────┬────────────────┐
│ context ID │ function name │ status   │ data         │ execution time │
├────────────┼───────────────┼──────────┼──────────────┼────────────────┤
│ ctx-001    │ fetch()       │ Pending  │ /my-app/data │ 10:30:45       │
│ ctx-002    │ then()        │ Resolved │ JSON data    │ 10:30:46       │
│ ctx-003    │ updateUI()    │ Running  │ DOM update   │ 10:30:47       │
└────────────┴───────────────┴──────────┴──────────────┴────────────────┘
```

**쉽게 이해하기**

- 브라우저는 마치 편지를 받아서 처리하는 사무실과 같습니다
- TLS 세션은 마치 비밀 대화를 위한 암호와 같습니다
- HTTP 캐시는 마치 자주 쓰는 문서를 책상 위에 두는 것과 같습니다
- JavaScript는 마치 받은 데이터를 화면에 표시하는 디자이너와 같습니다

**처리 주체**: 브라우저 네트워크 스택 (Chrome의 경우 Chromium 네트워크 스택, Safari의 경우 WebKit 네트워크 스택)

**네트워크 스택 처리**

- 무선 랜 카드가 패킷 수신
- 이더넷 프레임 → IP 패킷 → TCP 세그먼트 → HTTP 응답

**TLS 복호화**

- 브라우저가 TLS 복호화 수행
- 공유 비밀키로 응답 데이터 복호화

**HTTP 응답 파싱**

- 브라우저가 HTTP 응답 헤더 파싱
- Content-Type: application/json 확인
- 응답 본문을 JSON으로 파싱

**쉽게 이해하기**

- 브라우저가 우편물을 받아서 봉투를 뜯고 내용을 확인하는 과정
- TLS 복호화는 마치 암호로 된 편지를 해독하는 것과 같음
- HTTP 파싱은 마치 편지의 제목과 내용을 구분해서 읽는 것과 같음

### 10.2 JavaScript 처리

**처리 주체**: 브라우저 JavaScript 엔진 (Chrome의 경우 V8, Safari의 경우 JavaScriptCore)

**응답 데이터 처리**

```javascript
// fetch API 응답 처리
fetch('/my-app/data')
  .then(response => response.json())
  .then(data => {
    console.log('받은 데이터:', data);
    // DOM 업데이트 또는 상태 관리
  });
```

**DOM 업데이트**

- JavaScript가 JSON 데이터를 DOM 요소에 반영
- 사용자에게 결과 표시

**쉽게 이해하기**

- JavaScript는 마치 받은 데이터를 화면에 표시하는 디자이너와 같음
- 받은 JSON 데이터를 웹페이지의 적절한 위치에 배치
- 마치 받은 보고서를 읽고 화면에 예쁘게 정리해서 보여주는 것과 같음

## 기술 용어 정의

### 네트워크 기본 용어

**DNS (Domain Name System)**: 인터넷에서 도메인 이름을 IP 주소로 변환하는 분산 데이터베이스 시스템으로, 사람이 기억하기 쉬운 도메인 이름을 컴퓨터가 이해하는 숫자 IP 주소로 바꿔주는 역할을 합니다.

**IP 주소 (Internet Protocol Address)**: 인터넷에서 각 기기를 식별하는 고유한 숫자 주소로, IPv4는 192.168.1.1과 같은 형태, IPv6는 2001:0db8:85a3:0000:0000:8a2e:0370:7334와 같은 형태를 가집니다.

**MAC 주소 (Media Access Control Address)**: 네트워크 카드의 물리적 주소로, 00:11:22:33:44:55와 같은 형태를 가지며 전 세계에서 유일한 식별자입니다.

**포트 (Port)**: 컴퓨터에서 실행 중인 프로그램을 구분하는 번호로, HTTP는 80번, HTTPS는 443번, DNS는 53번 포트를 사용합니다.

**TTL (Time To Live)**: 패킷이 네트워크에서 살아있을 수 있는 최대 홉(라우터) 수로, 패킷이 무한히 순환하는 것을 방지합니다.

### OSI 7계층 모델

**OSI 7계층 모델**: 네트워크 통신을 7개의 계층으로 나누어 설명하는 표준 모델로, 각 계층은 특정 기능을 담당하며 하위 계층의 서비스를 받아 상위 계층에 서비스를 제공합니다.

**애플리케이션 계층 (Application Layer)**: 사용자와 직접 상호작용하는 계층으로, HTTP, FTP, DNS, SMTP 등의 프로토콜이 이 계층에서 동작합니다.

**표현 계층 (Presentation Layer)**: 데이터의 형식을 변환하는 계층으로, 암호화, 압축, 인코딩 등의 기능을 담당합니다.

**세션 계층 (Session Layer)**: 두 기기 간의 연결을 관리하는 계층으로, 연결의 시작과 종료, 동기화 등을 담당합니다.

**전송 계층 (Transport Layer)**: 데이터의 신뢰성 있는 전송을 보장하는 계층으로, TCP와 UDP 프로토콜이 이 계층에서 동작합니다.

**네트워크 계층 (Network Layer)**: 패킷의 경로를 결정하는 계층으로, IP 프로토콜과 라우팅이 이 계층에서 동작합니다.

**데이터 링크 계층 (Data Link Layer)**: 물리적 연결을 통해 데이터를 전송하는 계층으로, 이더넷 프레임과 MAC 주소가 이 계층에서 사용됩니다.

**물리 계층 (Physical Layer)**: 실제 전기 신호나 무선 신호로 데이터를 전송하는 계층으로, 케이블, 무선 신호, 네트워크 카드 등이 이 계층에 속합니다.

### 프로토콜 관련 용어

**HTTP (HyperText Transfer Protocol)**: 웹에서 데이터를 주고받기 위한 프로토콜로, 클라이언트-서버 모델을 기반으로 동작합니다.

**HTTPS (HTTP Secure)**: HTTP에 SSL/TLS 암호화를 추가한 보안 프로토콜로, 데이터의 기밀성과 무결성을 보장합니다.

**TCP (Transmission Control Protocol)**: 신뢰성 있는 데이터 전송을 보장하는 프로토콜로, 연결 지향적이며 데이터 손실을 방지합니다.

**UDP (User Datagram Protocol)**: 빠른 데이터 전송을 위한 프로토콜로, 연결 없이 동작하며 일부 데이터 손실을 허용합니다.

**TLS (Transport Layer Security)**: 인터넷에서 데이터를 안전하게 전송하기 위한 암호화 프로토콜로, 클라이언트와 서버 간의 통신을 암호화하여 데이터의 기밀성과 무결성을 보장합니다.

**SSL (Secure Sockets Layer)**: TLS의 이전 버전으로, 현재는 TLS로 대체되었지만 여전히 SSL이라는 용어가 널리 사용됩니다.

### 무선 네트워크 용어

**Wi-Fi**: 무선 근거리 통신망 기술로, IEEE 802.11 표준을 기반으로 합니다.

**802.11ac**: Wi-Fi의 한 표준으로, 5GHz 대역에서 최대 3.5Gbps의 속도를 제공합니다.

**QAM (Quadrature Amplitude Modulation)**: 디지털 데이터를 아날로그 신호로 변조하는 방식으로, 256-QAM은 256개의 서로 다른 신호 상태를 사용합니다.

**채널 (Channel)**: 무선 통신에서 사용하는 주파수 대역으로, 2.4GHz 대역에서는 1-13번 채널이 사용됩니다.

### 클라우드 및 컨테이너 용어

**Azure**: Microsoft에서 제공하는 클라우드 컴퓨팅 플랫폼으로, 가상 머신, 데이터베이스, 네트워킹 등의 서비스를 제공합니다.

**AKS (Azure Kubernetes Service)**: Azure에서 제공하는 관리형 쿠버네티스 서비스로, 컨테이너 오케스트레이션을 자동화합니다.

**Load Balancer**: 여러 서버에 들어오는 트래픽을 분산시켜 주는 네트워크 장비로, 서버의 부하를 균등하게 분배하고 가용성을 높이는 역할을 합니다.

**Virtual Network**: 클라우드에서 제공하는 가상 네트워크로, 실제 네트워크와 유사한 기능을 제공하지만 소프트웨어로 구현됩니다.

**NSG (Network Security Group)**: Azure에서 네트워크 트래픽을 필터링하는 보안 기능으로, 인바운드와 아웃바운드 규칙을 설정할 수 있습니다.

### 쿠버네티스 용어

**Kubernetes**: 컨테이너 오케스트레이션 플랫폼으로, 컨테이너의 배포, 확장, 관리를 자동화합니다.

**Pod**: 쿠버네티스에서 실행되는 최소 단위로, 하나 이상의 컨테이너를 포함할 수 있습니다.

**Service**: 쿠버네티스에서 Pod 집합에 대한 네트워크 접근을 제공하는 추상화 계층으로, Pod의 IP가 변경되어도 일관된 엔드포인트를 제공하고 로드 밸런싱 기능을 수행합니다.

**kube-proxy**: 쿠버네티스의 네트워크 프록시 컴포넌트로, Service의 가상 IP를 실제 Pod IP로 변환합니다.

**iptables**: Linux에서 패킷 필터링과 NAT를 수행하는 도구로, 네트워크 규칙을 설정하여 트래픽을 제어합니다.

**ClusterIP**: 쿠버네티스 Service의 기본 타입으로, 클러스터 내부에서만 접근 가능한 가상 IP를 제공합니다.

**Endpoint**: 쿠버네티스에서 Service가 연결할 Pod의 IP와 포트 정보를 담고 있는 리소스입니다.

### 웹 서버 및 애플리케이션 용어

**Nginx**: 고성능 웹서버로, 리버스 프록시, 로드 밸런서, HTTP 캐시 등의 기능을 제공합니다.

**Spring Boot**: Java 기반의 웹 애플리케이션 프레임워크로, 빠른 개발과 자동 설정을 지원합니다.

**DispatcherServlet**: Spring MVC의 핵심 컴포넌트로, 모든 HTTP 요청을 받아서 적절한 컨트롤러로 라우팅합니다.

**JPA (Java Persistence API)**: Java에서 데이터베이스와 상호작용하기 위한 표준 API로, 객체 관계 매핑을 제공합니다.

**Hibernate**: JPA의 구현체로, Java 객체를 데이터베이스 테이블과 매핑하는 ORM 프레임워크입니다.

**JSON (JavaScript Object Notation)**: 데이터를 주고받기 위한 경량화된 데이터 형식으로, 사람이 읽기 쉽고 기계가 파싱하기 쉬운 형태입니다.

### 브라우저 관련 용어

**Chrome**: Google에서 개발한 웹 브라우저로, Chromium 엔진을 기반으로 합니다.

**Safari**: Apple에서 개발한 웹 브라우저로, WebKit 엔진을 기반으로 합니다.

**BoringSSL**: Google에서 개발한 SSL/TLS 라이브러리로, OpenSSL을 기반으로 하며 보안과 성능을 개선했습니다.

**SecureTransport**: Apple에서 개발한 SSL/TLS 라이브러리로, macOS와 iOS에서 사용됩니다.

**V8**: Google에서 개발한 JavaScript 엔진으로, Chrome과 Node.js에서 사용됩니다.

**JavaScriptCore**: Apple에서 개발한 JavaScript 엔진으로, Safari에서 사용됩니다.

### 운영체제 관련 용어

**Windows**: Microsoft에서 개발한 운영체제로, 데스크톱과 서버 환경에서 널리 사용됩니다.

**macOS**: Apple에서 개발한 운영체제로, Mac 컴퓨터에서 사용됩니다.

**BSD (Berkeley Software Distribution)**: Unix 계열의 운영체제로, macOS의 네트워크 스택 기반이 됩니다.

**mDNSResponder**: macOS에서 DNS 해석을 담당하는 서비스로, 로컬 DNS 캐시와 멀티캐스트 DNS를 처리합니다.

### 네트워크 하드웨어 용어

**라우터**: 네트워크 간의 패킷을 전달하는 장비로, 라우팅 테이블을 기반으로 최적 경로를 결정합니다. 서로 다른 네트워크 간의 통신을 중계하며, IP 주소를 사용하여 패킷의 목적지를 판단합니다.

**스위치**: 네트워크 내에서 패킷을 전달하는 장비로, MAC 주소를 기반으로 패킷을 전송합니다. 각 포트에 연결된 기기의 MAC 주소를 학습하여 해당 포트로만 패킷을 전송하며, 브로드캐스트 패킷은 모든 포트로 전송합니다.

**인터넷 공유기**: 가정이나 사무실의 여러 기기를 인터넷에 연결하는 장비로, NAT(Network Address Translation) 기능을 제공합니다. 사설 IP 주소를 공인 IP 주소로 변환하여 여러 기기가 하나의 공인 IP를 공유할 수 있게 합니다.

**네트워크 어댑터**: 컴퓨터를 네트워크에 연결하는 하드웨어로, 이더넷 카드나 무선 랜 카드가 이에 해당합니다. 디지털 데이터를 물리적 신호로 변환하여 네트워크로 전송하고, 수신한 신호를 디지털 데이터로 변환합니다.

**POP (Point of Presence)**: 인터넷 서비스 제공업체(ISP)의 네트워크 접속점으로, 사용자와 인터넷 백본을 연결합니다. 지역별로 설치되어 사용자와 ISP의 백본 네트워크를 연결하는 역할을 합니다.

**허브**: 물리 계층에서 동작하는 네트워크 장비로, 수신한 신호를 모든 포트로 전송하는 단순한 장비입니다. 충돌 도메인을 공유하여 네트워크 성능을 저하시킬 수 있으며, 현재는 스위치로 대체되어 거의 사용되지 않습니다.

**게이트웨이**: 서로 다른 네트워크 프로토콜이나 아키텍처 간의 통신을 중계하는 장비로, 라우터의 한 종류입니다. 로컬 네트워크와 인터넷을 연결하는 역할을 하며, NAT(Network Address Translation) 기능을 제공합니다.

### 보안 관련 용어

**암호화 (Encryption)**: 데이터를 읽을 수 없는 형태로 변환하는 과정으로, 데이터의 기밀성을 보장합니다.

**복호화 (Decryption)**: 암호화된 데이터를 원래 형태로 되돌리는 과정입니다.

**암호화 스위트 (Cipher Suite)**: 암호화에 사용되는 알고리즘 조합으로, 키 교환, 암호화, 해시 함수 등을 포함합니다.

**ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)**: 키 교환을 위한 암호화 알고리즘으로, 타원곡선 암호화를 사용합니다.

### 데이터베이스 관련 용어

**SQL (Structured Query Language)**: 관계형 데이터베이스에서 데이터를 조회하고 조작하기 위한 표준 언어입니다.

**ResultSet**: 데이터베이스 쿼리의 결과를 담고 있는 객체로, 조회된 데이터에 접근할 수 있는 인터페이스를 제공합니다.

**Entity**: JPA에서 데이터베이스 테이블과 매핑되는 Java 클래스로, 객체 관계 매핑의 핵심 개념입니다.

### 기타 용어

**직렬화 (Serialization)**: 객체를 바이트 스트림으로 변환하는 과정으로, 네트워크 전송이나 저장을 위해 사용됩니다.

**역직렬화 (Deserialization)**: 바이트 스트림을 객체로 변환하는 과정입니다.

**캐시 (Cache)**: 자주 사용되는 데이터를 빠른 저장소에 보관하는 기술로, 성능 향상을 위해 사용됩니다.

**홉 (Hop)**: 네트워크에서 패킷이 한 라우터에서 다음 라우터로 이동하는 단계를 의미합니다.

**라운드 로빈 (Round Robin)**: 로드 밸런싱 알고리즘의 하나로, 요청을 순차적으로 각 서버에 분배하는 방식입니다.

### 네트워크 프로토콜 상세 용어

**ARP (Address Resolution Protocol)**: IP 주소를 MAC 주소로 변환하는 프로토콜로, 네트워크 계층의 IP 주소를 데이터 링크 계층의 MAC 주소로 매핑하는 역할을 합니다. 브로드캐스트를 통해 같은 네트워크 세그먼트 내의 모든 기기에 질의를 보내고, 해당 IP 주소를 가진 기기만 응답하여 MAC 주소를 획득합니다.

**브로드캐스트 (Broadcast)**: 네트워크 세그먼트 내의 모든 기기에게 패킷을 전송하는 방식으로, MAC 주소 FF:FF:FF:FF:FF:FF를 사용하여 모든 기기가 패킷을 수신하도록 합니다. ARP 요청이나 DHCP 요청과 같이 특정 기기를 찾을 때 사용되며, 네트워크 효율성 측면에서는 제한적으로 사용됩니다.

**체크섬 (Checksum)**: 데이터 전송 중 오류를 검출하기 위한 값으로, 전송할 데이터를 특정 알고리즘으로 계산하여 얻은 값을 패킷에 포함시킵니다. 수신측에서 같은 알고리즘으로 계산한 값과 비교하여 데이터 무결성을 확인하며, TCP, UDP, IP 헤더에서 사용됩니다.

**FCS (Frame Check Sequence)**: 이더넷 프레임의 마지막 4바이트로, CRC-32 알고리즘을 사용하여 프레임 전체의 오류를 검출합니다. 전송 중 발생한 비트 오류를 감지하여 손상된 프레임을 폐기하고, 데이터 링크 계층에서 신뢰성 있는 전송을 보장합니다.

**TTL (Time To Live)**: 패킷이 네트워크에서 살아있을 수 있는 최대 홉(라우터) 수로, 각 라우터를 통과할 때마다 1씩 감소합니다. TTL이 0이 되면 패킷이 폐기되어 무한 루프를 방지하며, traceroute 명령어에서 각 홉의 정보를 얻기 위해 사용됩니다.

### 네트워크 하드웨어 상세 용어

**스위치 (Switch)**: 데이터 링크 계층에서 동작하는 네트워크 장비로, MAC 주소 테이블을 기반으로 패킷을 전송합니다. 각 포트에 연결된 기기의 MAC 주소를 학습하여 해당 포트로만 패킷을 전송하며, 브로드캐스트 패킷은 모든 포트로 전송합니다.

**허브 (Hub)**: 물리 계층에서 동작하는 네트워크 장비로, 수신한 신호를 모든 포트로 전송하는 단순한 장비입니다. 충돌 도메인을 공유하여 네트워크 성능을 저하시킬 수 있으며, 현재는 스위치로 대체되어 거의 사용되지 않습니다.

**라우터 (Router)**: 네트워크 계층에서 동작하는 장비로, 서로 다른 네트워크 간의 패킷을 전달합니다. 라우팅 테이블을 기반으로 최적 경로를 결정하며, IP 주소를 사용하여 패킷의 목적지를 판단합니다.

**게이트웨이 (Gateway)**: 서로 다른 네트워크 프로토콜이나 아키텍처 간의 통신을 중계하는 장비로, 라우터의 한 종류입니다. 로컬 네트워크와 인터넷을 연결하는 역할을 하며, NAT(Network Address Translation) 기능을 제공합니다.

### 네트워크 주소 관련 용어

**사설 IP 주소 (Private IP Address)**: 인터넷에 직접 연결되지 않는 내부 네트워크에서 사용하는 IP 주소로, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 범위에 속합니다. NAT를 통해 공인 IP 주소로 변환되어 인터넷과 통신하며, 여러 네트워크에서 중복 사용 가능합니다.

**공인 IP 주소 (Public IP Address)**: 인터넷에서 전 세계적으로 유일한 IP 주소로, ISP에서 할당받아 사용합니다. 인터넷에 직접 연결되어 전 세계 어디서든 접근 가능하며, 유료로 할당받아 사용하는 제한된 자원입니다.

**NAT (Network Address Translation)**: 사설 IP 주소를 공인 IP 주소로 변환하는 기술로, 여러 기기가 하나의 공인 IP 주소를 공유할 수 있게 합니다. 포트 번호를 추가로 사용하여 여러 연결을 구분하며, 보안상 내부 네트워크 구조를 숨기는 효과가 있습니다.

**서브넷 마스크 (Subnet Mask)**: IP 주소의 네트워크 부분과 호스트 부분을 구분하는 32비트 값으로, 네트워크 주소를 계산하는 데 사용됩니다. 255.255.255.0과 같은 형태로 표현되며, CIDR 표기법으로 /24와 같이 표현할 수도 있습니다.

### 네트워크 프로토콜 스택 용어

**TCP/IP 스택**: 인터넷에서 사용하는 표준 네트워크 프로토콜 스택으로, TCP(전송 계층)와 IP(네트워크 계층)를 기반으로 구성됩니다. 애플리케이션 계층, 전송 계층, 네트워크 계층, 네트워크 액세스 계층으로 나뉘며, 각 계층은 독립적으로 동작하면서 하위 계층의 서비스를 사용합니다.

**소켓 (Socket)**: 네트워크 통신을 위한 프로그래밍 인터페이스로, IP 주소와 포트 번호의 조합으로 구성됩니다. TCP 소켓과 UDP 소켓으로 구분되며, 애플리케이션이 네트워크 통신을 쉽게 구현할 수 있도록 추상화된 인터페이스를 제공합니다.

**포트 번호 (Port Number)**: 컴퓨터에서 실행 중인 프로그램을 구분하는 16비트 번호로, 0부터 65535까지의 범위를 가집니다. 0-1023은 잘 알려진 포트(Well-known ports)로 시스템에서 예약되어 있으며, 1024-65535는 동적 포트로 애플리케이션이 자유롭게 사용할 수 있습니다.

### 무선 네트워크 상세 용어

**802.11**: IEEE에서 정의한 무선 근거리 통신망 표준으로, Wi-Fi의 기술적 기반이 됩니다. 802.11a, 802.11b, 802.11g, 802.11n, 802.11ac, 802.11ax 등 다양한 버전이 있으며, 각각 다른 주파수 대역과 전송 속도를 지원합니다.

**QAM (Quadrature Amplitude Modulation)**: 디지털 데이터를 아날로그 신호로 변조하는 방식으로, 진폭과 위상을 동시에 변화시켜 여러 비트를 한 번에 전송합니다. 256-QAM은 8비트(256개 상태)를 한 번에 전송하며, 더 높은 QAM은 더 많은 데이터를 전송할 수 있지만 노이즈에 민감합니다.

**채널 (Channel)**: 무선 통신에서 사용하는 주파수 대역으로, 2.4GHz 대역에서는 1-13번 채널이 사용됩니다. 인접한 채널 간에는 간섭이 발생할 수 있어 1, 6, 11번 채널을 주로 사용하며, 5GHz 대역에서는 더 많은 채널을 사용할 수 있습니다.

**SSID (Service Set Identifier)**: 무선 네트워크를 식별하는 이름으로, 최대 32자까지 설정할 수 있습니다. 같은 SSID를 가진 액세스 포인트들은 하나의 무선 네트워크를 구성하며, 클라이언트는 SSID를 통해 연결할 네트워크를 선택합니다.

### 보안 프로토콜 상세 용어

**TLS 핸드셰이크**: TLS 연결을 수립하기 위한 협상 과정으로, 클라이언트와 서버 간의 암호화 방식과 키를 결정합니다. ClientHello, ServerHello, 키 교환, Finished 메시지로 구성되며, 대칭키 암호화를 위한 공유 비밀키를 안전하게 생성합니다.

**대칭키 암호화 (Symmetric Encryption)**: 암호화와 복호화에 같은 키를 사용하는 방식으로, AES, ChaCha20 등의 알고리즘이 사용됩니다. 비대칭키 암호화보다 빠르지만 키 교환 과정이 필요하며, TLS에서는 대화 내용을 암호화하는 데 사용됩니다.

**비대칭키 암호화 (Asymmetric Encryption)**: 공개키와 개인키를 사용하는 암호화 방식으로, RSA, ECDHE 등의 알고리즘이 사용됩니다. 키 교환과 디지털 서명에 사용되며, TLS 핸드셰이크에서 대칭키를 안전하게 교환하는 데 사용됩니다.

**디지털 인증서 (Digital Certificate)**: 공개키의 소유자를 증명하는 전자 문서로, 인증 기관(CA)에서 발급합니다. 서버의 신원을 확인하고 중간자 공격을 방지하며, 브라우저에서 HTTPS 연결의 신뢰성을 판단하는 기준이 됩니다.
