- 목이 취약한 테스트, 즉 리팩터링 내성이 부족한 테스트를 초래하는 것을 살펴본다.
- 그러나 목을 적용할 수 있는 경우가 있고, 심지어 목 사용이 바람직한 경우도 있다.

- 런던파는 테스트 대상 코드 조각을 서로 분리하고 불변 의존성을 제외한 모든 의존성을 테스트 대역을 써서 격리하자고 한다.
- 고정파는 단위 테스트를 분리해서 병렬로 실행할 수 있게 하자고 한다. 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용한다.

# 목과 스텁 구분

- 목은 테스트 대상 시스템(SUT)과 그 협력자 사이의 상호 작용을 검사하라 수 있는 테스트 대역이다.
- 테스트 대역에 또 다른 유형이 있는데, 바로 스텁(stub)이다.

- 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.
- 제라드 메스자로스(Gerard Meszaros)에 따르면, 테스트 대역에는 더미(dummy), 스텁, 스파이(spy), 목, 페이크(fake)라는 다섯 가지가 있다. 실제로는 목과 스텁의 두 가지 유형으로 나눌 수 있다.
- 목
  - 목
    - 프레임워크의 도움을 받는다.
  - 스파이
    - 목과 같은 역할을 한다.
    - 수동으로 작성한다.
    - 직접 작성한 목 (handwritten mock) 이라고 부르기도 한다.
- 스텁
  - 스텁
    - 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성이다.
  - 더미
    - null 값이나 가짜 문자열과 같이 단순하고 하드코딩된 값이다.
    - SUT 의 메서드 시그니처를 만족시키기 위해 사용하고 최종 결과를 만드는 데 영향을 주지 않는다.
  - 페이크
    - 대다수의 목적에 부합하는 스텁과 같다.
    - 보통 아직 존재하지 않는 의존성을 대체하고자 구현한다.

- 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 이러한 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
- 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
- 목은 SUT 와 관련 의존성 간의 상호 작용을 모방하고 검사하는 반면, 스텁은 모방만 한다. 이는 중요한 차이점이다.
- Mock 클래스는 도구로서의 목인데 반해, 해당 클래스의 인스턴스인 mock 은 테스트 대역으로서의 목이다. 도구로서의 목을 사용해 목과 스텁, 이 두 가지 유형의 테스트 대역을 생성할 수 있기 때문에 도구로서의 목과 테스트 대역으로어싀 목을 혼동하지 않는 것이 중요하다.

- 스텁으로 상호 작용을 검증하지 말라
- 스텁은 SUT 가 출력을 생성하도록 입력을 제공한다.
- 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.
- 테스트에서 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아니라 최종 결과(이상적으로 비개발자들에게 의미가 있어야 함)를 검증하는 것뿐이다.
- 최종 결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세(overspecification)라고 부른다.
- 스텁과의 상호 작용을 확인하는 것은 쉽게 발견할 수 있는 결함이다. 테스가 스텁과의 상호 작용을 확인해서는 안 되기 때문이다.

# 목과 CQS (Command Query Separation)

- 명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메서드(void 반환)다.
- 조회는 사이트 이펙트가 없고 삾을 반환한다.
- CQS 원칙에서 명령은 목에 해당하는 반면, 조회는 스텁과 일치한다.

# 식별할 수 있는 동작과 구현 세부 사항

- 테스트 취약성은 좋은 단위 테스트의 특성중 리팩터링 내성에 해당한다.
- 테스트가 단위 테스트 영역에 있고 엔드 투 엔드 테스트 범주로 바뀌지 않는 한 리팩터링 내성을 최대한 활용하는 것이 좋다. 엔드 투 엔드 테스트 범주로 넘어가면, 리팩터링 내성이 가장 뛰어나도 일반적으로 유지 보수하기가 훨씬 까다롭다.
- 테스트에 거짓 양성이 있는 주요 이유는 코드의 구현 세부 사항과 결합되어 있기 때문이다. 이러한 강결합을 피하는 방법은 코드가 생성하는 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부 사항과 테스트를 가능한 한 떨어뜨리는 것뿐이다.
- 즉, 테스트는 '어떻게'가 아니라 '무엇'에 중점을 둬야 한다.

## 식별할 수 있는 동작은 공개 API 와 다르다

- 클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙이 있다. 단일한 목표를 달성하고자 클래스에서 로출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.

## 잘 설계된 API와 캡슐화

- 캡슐화는 불변성 위반이라고도 하는 모순을 방지하는 조치다.
- 구현 세부 사항을 노출하면 불변성 위반을 가져온다.
- 캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다.
- 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.
- 모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외애는 다른 선택지가 없으며, 이로 인해 리팩터링 내성도 자동으로 좋아진다.
- 연산과 상태를 최소한으로 노출해야 한다.
- 클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개해야 하며, 다른 모든 것은 구현 세부 사항이므로 비공개 API 뒤에 숨겨야 한다.
- 코드의 공개 여부와 목적의 관계. 구현 세부 사항을 공개하지 말라.

|     | 식별할 수 있는 동작 | 구현 세부 사항 |
|-----|-------------|----------|
| 공개  | 좋음          | 나쁨       |
| 비공개 | 해당 없음       | 좋음       |

# 목과 테스트 취약성 간의 관계

## 육각형 아키텍처 정의

- 대표적인 애플리케이션은 도메인 계층과 애플리케이션 서비스 계층으로 구성된다.
- 도메인 계층에는 애플리케이션의 비즈니스 로직이 있다.
- 애플리케이션 서비스는 이 로직으르 비즈니스 유스케이스와 결합한다. (-> 유스케이스라는 것에 대한 용어 정의와 유스케이스에 대한 설명이 있으면 좋다.)

- 육각형 아키텍처라는 용어는 앨리스터 코오번(Alistair Cockburn)이 처음 소개했다. 그 목적은 세 가지 중요한 지침을 강조하는 것이다.
  - 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
  - 애플리케이션 내부 통신
    - 애플리케이션 서비스 계층과 도메인 계층 간에 관심사를 분리하는 것은 애플리케이션 서비스 계층이 도메인 계층에 대해 아는 것을 의미하지만, 반대는 아니다.
    - 도메인 계층은 외부 환경에서 완전히 격리돼야 한다.
  - 애플리케이션 간의 통신
    - 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결된다.

- 서로 다른 계층의 테스트는 동일한 동작을 서로 다른 수준으로 검증하는 프랙탈 특성이 있다.

- 코드베이스의 공개 API 를 항상 비즈니스 요구 사항에 따라 추적하라는 이 지침은 대부분의 도메인 클래스와 애플리케이션 서비스에 적용되지만, 유틸리티나 인프라 코드에는 적용되지 않는다.

## 시스템 내부 통신과 시스템 간 통신

- 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다.
  - 시스템 내부 통신은 구현 세부 사항이고, 시스템 간 통신은 그렇지 않다.
  - 연산을 수행하기 위한 도메인 클래스 간의 협력은 식별할 수 있는 동작이 아니므로 시스템 내부 통신은 구현 세부 사항에 해당한다.
- 시스템 간 통신은 애플리케이션이 다른 애플리케이션과 통신하는 것을 말한다.
  - 시스템 외부 환경과 통신하는 방식은 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타낸다.
  - 시스템 내부에서 하는 리팩터링과 다르게, 외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야 한다.
- 목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다.
- 반대로 시스템 내 클래스 간의 통신을 검증하는 데 사용하면 테스트가 구현 세부 사항과 결합되며, 그에 따라 리팩터링 내성 지표가 미흡해진다.

## 단위 테스트의 고전파와 런던파 재고

|     | 격리주체   | 단위의크기            | 테스트 대역 사용 대상    |
|-----|--------|------------------|-----------------|
| 런던파 | 단위     | 단일 클래스           | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성          |

- 런던파는 불변 의존성으르 제외한 모든 의존성에 목 사용을 권장하며 시스템 내 통신과 시스템 간 통신을 구분하지 않는다.
- 목을 무분별하게 사용하면 종종 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다.
- 리팩터링 내성이 저하되면 테스트는 가치가 없어진다.

## 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다.

- 의존성 유형
  - 공유 의존성 : 테스트 간에 공유하는 의존성 (제품 코드가 아님)
  - 프로세스 외부 의존성 : 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성 (예를 들어 데이터베이스, 메시지 버스, SMTP 서비스 등)
  - 비공개 의존성 : 공유하지 않는 모든 의존성

- 테스트를 병렬적, 순차적 또는 임의의 순서로 실행할 수 있는 것을 테스트 격리라고 부른다.

## 목을 사용한 동작 검증

- 종종 목이 동작을 검증한다고 하지만, 대부분의 경우 그렇지 않다.
- 목표를 달성하고자 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과는 아무런 관계가없다. 이것은 구현 세부 사항이다.
- 목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할때와 이러한 상호 작용의 사이드 이펙트가 외부 환경애서 보일 때만 동작과 관련이 있다.

# 책에서의 요약

- 테스트 대역은 테스트에서 비제품 가짜 의존성의 모든 유형으르 설명하는 포괄적인 용어다. 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 등의 다섯 가지 변형이 있는데, 이는 다시 목과 스텁이라는 두 가지 유형으로 분류할 수 있다. 스파이는 기능적으로 목과 같고, 더미와 페이크는 스텁과 같은 역할을 한다.
- 목은 외부로 나가는 상호 작용(SUT에서 의존성으로의 호출로, 해당 의존성의 상태를 변경)을 모방하고 검사하는 데 도움이 된다. 스텁은 내부로 들어오는 상호 작용(SUT가 해당 의존성을 호출해 입력 데이터를 가져옴)을 모방하는 데 도움이 된다.
- Mock(도구)은 목(테스트 대역)이나 스텁을 만드는 데 사용할 수 있는 목 라이브러리의 클래스다.
- 스텁과의 상호 작용을 검증하면 취약한 테스트로 이어진다. 이러한 상호 작용은 최종 결과와 일치하지 않는다. 이는 결과로 가는 중간 단계로, 구현 세부 사항에 해당 한다.
- 명령 조회 분리(CQS) 원칙에 따르면, 모든 메서드가 명령 또는 조회 중 하나여야 하지만 둘 다는 안 된다. 명령을 대체하는 테스트 대역은 목이다. 조회를 대체하는 테스튿 대역은 스텁이다.
- 모든 제품 코드는 공개 API 인지 비공개 API 인지와 식별할 수 있는 동작인지 구현 세부 사항인지라는 두 가지 차원으로 분류할 수 있다. 코드의 공개성은 private, public, internal 키워드 등 접근 제한자에 의해 제어된다. 다음 요구 사항을 하나라도 충족하면 식별할 수 있는 동작이다. (둘 다 아니면 구현 세부 사항이다.)
  - 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 또는 둘 다 하는 메서드다.
  - 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다.
- 잘 설걔된 코드는 식별할 수 있는 동작이 공개 API 와 일치하고 구현 세부 사항이 비공개 APi 뒤에 숨겨져 있는 코드다. 공개 API 가 식별할 수 있는 동작 이상으로 커지면 코드는 구현 세부 사항을 유출한다.
- 캡슐화는 코드를 불변성 위반으로부터 보호하는 행위다. 클라이언트는 구현 세부 사항을 사용해 코드의 불변성을 우회할 수 있기 대문에 구현 세부 사항을 노출하면 캡슐화가 위반되는 경우가 종종 있다.
- 육각형 아키텍처는 상호 작용하는 애플리케이션의 집합이고 각 애플리케이션은 육각형으로 표시한다. 각 육각형은 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다.
- 육각형 아키텍처는 다음과 같은 세 가지 관점을 강조한다.
  - 도메인과 애플리케이션 서비스 계층 간의 영향 분리. 도메인 계층은 비즈니스 로직을 책임져야 하고, 애플리케이션 서비스는 도메인 계층과 외부 애플리케이션 간의 작업을 조정해야 한다.
  - 애플리케이션 서비스 계층에서 도메인 계층으로의 단방향 의존성 흐름. 도메인 계층 내 클래스는 서로에게만 의존해야 하고, 애플리케이션 서비스 계층의 클래스에 의존해서는 안 된다.
  - 외부 애플리케이션은 애플리케이션 서비스 계층이 유지하는 공통 인터페이스를 통해 열결된다. 아무도 도메인 계층에 직접 액세스할 수 없다.
- 육각형의 각 계층은 식별할 수 있는 동작을 나타내며 각각의 구현 세부 사항이 있다.
- 애플리케이션에는 시스템 내부 통신과 시스템 간 통신이라는 두 가지 통신 유형이 있다. 시스템 내부 통신은 애플리케이션 내 클래스 간의 통신이다. 시스템 간 통신은 식별할 수 있는 동작이다. 애플리케이션을 통해서만 접근할 수 있는 외부 시스템과의 상호 작용도 구현 세부 사항인데, 그 결과의 사이드 이펙트를 외부에서 확인할 수 없기 때문이다.
- 시스템 내 통신을 검증하고자 목을 사용하면 취약한 테스트로 이어진다. 따라서 시스템 간 통신(애플리케이션 경계를 넘는 통신)과 해당 통신의 사이드 이펙트가 외부 환경에서 보일 때만 목을 사용하는 것이 타당하다.
