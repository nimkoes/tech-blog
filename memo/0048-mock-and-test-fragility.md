- 목이 취약한 테스트, 즉 리팩터링 내성이 부족한 테스트를 초래하는 것을 살펴본다.
- 그러나 목을 적용할 수 있는 경우가 있고, 심지어 목 사용이 바람직한 경우도 있다.

- 런던파는 테스트 대상 코드 조각을 서로 분리하고 불변 의존성을 제외한 모든 의존성을 테스트 대역을 써서 격리하자고 한다.
- 고정파는 단위 테스트를 분리해서 병렬로 실행할 수 있게 하자고 한다. 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용한다.

# 목과 스텁 구분

- 목은 테스트 대상 시스템(SUT)과 그 협력자 사이의 상호 작용을 검사하라 수 있는 테스트 대역이다.
- 테스트 대역에 또 다른 유형이 있는데, 바로 스텁(stub)이다.

- 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어다.
- 제라드 메스자로스(Gerard Meszaros)에 따르면, 테스트 대역에는 더미(dummy), 스텁, 스파이(spy), 목, 페이크(fake)라는 다섯 가지가 있다. 실제로는 목과 스텁의 두 가지 유형으로 나눌 수 있다.
- 목
  - 목
    - 프레임워크의 도움을 받는다.
  - 스파이
    - 목과 같은 역할을 한다.
    - 수동으로 작성한다.
    - 직접 작성한 목 (handwritten mock) 이라고 부르기도 한다.
- 스텁
  - 스텁
    - 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성이다.
  - 더미
    - null 값이나 가짜 문자열과 같이 단순하고 하드코딩된 값이다.
    - SUT 의 메서드 시그니처를 만족시키기 위해 사용하고 최종 결과를 만드는 데 영향을 주지 않는다.
  - 페이크
    - 대다수의 목적에 부합하는 스텁과 같다.
    - 보통 아직 존재하지 않는 의존성을 대체하고자 구현한다.

- 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데 도움이 된다. 이러한 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
- 스텁은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
- 목은 SUT 와 관련 의존성 간의 상호 작용을 모방하고 검사하는 반면, 스텁은 모방만 한다. 이는 중요한 차이점이다.
- Mock 클래스는 도구로서의 목인데 반해, 해당 클래스의 인스턴스인 mock 은 테스트 대역으로서의 목이다. 도구로서의 목을 사용해 목과 스텁, 이 두 가지 유형의 테스트 대역을 생성할 수 있기 때문에 도구로서의 목과 테스트 대역으로어싀 목을 혼동하지 않는 것이 중요하다.

- 스텁으로 상호 작용을 검증하지 말라
- 스텁은 SUT 가 출력을 생성하도록 입력을 제공한다.
- 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.
- 테스트에서 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아니라 최종 결과(이상적으로 비개발자들에게 의미가 있어야 함)를 검증하는 것뿐이다.
- 최종 결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세(overspecification)라고 부른다.
- 스텁과의 상호 작용을 확인하는 것은 쉽게 발견할 수 있는 결함이다. 테스가 스텁과의 상호 작용을 확인해서는 안 되기 때문이다.

# 목과 CQS (Command Query Separation)

- 명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메서드(void 반환)다.
- 조회는 사이트 이펙트가 없고 삾을 반환한다.
- CQS 원칙에서 명령은 목에 해당하는 반면, 조회는 스텁과 일치한다.

# 식별할 수 있는 동작과 구현 세부 사항

- 테스트 취약성은 좋은 단위 테스트의 특성중 리팩터링 내성에 해당한다.
- 테스트가 단위 테스트 영역에 있고 엔드 투 엔드 테스트 범주로 바뀌지 않는 한 리팩터링 내성을 최대한 활용하는 것이 좋다. 엔드 투 엔드 테스트 범주로 넘어가면, 리팩터링 내성이 가장 뛰어나도 일반적으로 유지 보수하기가 훨씬 까다롭다.
- 테스트에 거짓 양성이 있는 주요 이유는 코드의 구현 세부 사항과 결합되어 있기 때문이다. 이러한 강결합을 피하는 방법은 코드가 생성하는 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부 사항과 테스트를 가능한 한 떨어뜨리는 것뿐이다.
- 즉, 테스트는 '어떻게'가 아니라 '무엇'에 중점을 둬야 한다.

## 식별할 수 있는 동작은 공개 API 와 다르다

- 클래스가 구현 세부 사항을 유출하는지 판단하는 데 도움이 되는 유용한 규칙이 있다. 단일한 목표를 달성하고자 클래스에서 로출해야 하는 연산의 수가 1보다 크면 해당 클래스에서 구현 세부 사항을 유출할 가능성이 있다.

## 잘 설계된 API와 캡슐화

- 캡슐화는 불변성 위반이라고도 하는 모순을 방지하는 조치다.
- 구현 세부 사항을 노출하면 불변성 위반을 가져온다.
- 캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다.
- 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
- 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.
- 모든 구현 세부 사항을 비공개로 하면 테스트가 식별할 수 있는 동작을 검증하는 것 외애는 다른 선택지가 없으며, 이로 인해 리팩터링 내성도 자동으로 좋아진다.
- 연산과 상태를 최소한으로 노출해야 한다.
- 클라이언트가 목표를 달성하는 데 직접적으로 도움이 되는 코드만 공개해야 하며, 다른 모든 것은 구현 세부 사항이므로 비공개 API 뒤에 숨겨야 한다.
- 코드의 공개 여부와 목적의 관계. 구현 세부 사항을 공개하지 말라.

|     | 식별할 수 있는 동작 | 구현 세부 사항 |
|-----|-------------|----------|
| 공개  | 좋음          | 나쁨       |
| 비공개 | 해당 없음       | 좋음       |

# 목과 테스트 취약성 간의 관계


