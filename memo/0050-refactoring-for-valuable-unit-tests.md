# 리팩터링 할 코드 식별하기

## 코드의 네 가지 유형

모든 제품 코드는 2차원으로 분류할 수 있다.

- 코드 복잡도 (code complexity) 또는 도메인 유의성 (domain significance)
- 클래스 또는 메서드가 가진 협력자 수

코드 복잡도는 코드 내 의사결정(분기) 지점 수로 정의 한다. 이 숫자가 클수록 복잡도는 더 높아진다. 도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미있는지를 나타낸다. 협력자는 가변 의존성이거나 프로세스 외부 의존성(또는 둘 다)이다.

코드 복잡도, 도메인 유의성, 협력자 슈의 조합으로 코드 유형을 네 가지로 구분할 수 있다.

### 도메인 모델과 알고리즘

보톨 복잡한 코드는 도메인 모델이지만, 100%는 아니다. 문제 도메인과 직접적으로 관련이 없는 복잡한 알고리즘이 있을 수 있다.

### 간단한 코드

C# 에서 이러한 코드의 예로 매개변수가 없는 생성자와 한 줄 속성 등이 있다. 협력자가 있는 경우가 거의 없고 복잡도나 도메인 유의성도 거의 없다.

### 컨트롤러

이 코드는 복잡하거나 비즈니스에 중요한 작업을 하는 것이 아니라 도메인 클래스와 외부 애플리케이션 같은 다른 구성 요소의 작업을 조정한다.

### 지나치게 복잡한 코드

이러한 코드는 두 가지 지표 모두 높다. 협력자가 많으며 복잡하거나 중요하다. 한 가지 예로 덩치가 큰 컨트롤러(복잡한 작업을 어디에도 위임하지 않고 모든 것을 스스로 하는 컨트롤러)가 있다.

|                 | 협력자 수 ↓      | 협력자수 ↑      |
|-----------------|--------------|-------------|
| 복잡도 및 도메인 유의성 ↑ | 도메인 모델과 알고리즘 | 지나치게 복잡한 코드 |
| 복잡도 및 도메인 유의성 ↓ | 간단한 코드       | 컨트롤러        |

지나치게 복잡한 코드를 알고리즘과 컨트롤러로 나눠서 리팩터링하라. 이상적으로는 '지나치게 복잡한 코드'가 있으면 안 된다.

## 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추출해 코드를 테스트할 필요가 없도록 간단하게 만든다. 추출된 로직은 테스트하기 어려운 의존성에서 분리된 다른 클래스로 이동한다.

육각형 아키텍처와 함수형 아키텍처 모두 정확히 이 패턴을 구현한다.

함수형 아키텍터의 함수형 코어와 육각형 아키텍처의 도메인 계층은 '도메인 모델과 알고리즘'에 속하며, 협력자가 거의 없고 복잡도와 도메인 유의성이 높다. 가변 셸(함수형 아키텍처)과 애플리케이션 서비스 계층(육각형 아키텍처)은 컨트롤러에 속한다.

# 가치 있는 단위 테스트를 위한 리팩터링하기

## 고객 관리 시스템 소개

- 명시적인 의존성과 암시적인 의존성
- 도메인 유의성이 높은 코드에서 프로세스 외부 협력자는 사용하면 안 된다.
- 도메인 클래스가 스스로 데이터베이스를 검색하고 다시 저장하는 이러한 방식을 활성 레코드 (Active Pattern) 패턴 이라고 한다.

## 1단계 : 암시적 의존성을 명시적으로 만들기

- 도메인 모델은 직접적으로든 간접적으로든 (인터페이스를 통해) 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다.
- 이것이 육각형 아키텍처에서 바라는 바다.
- 도메인 모델은 외부 시스템과의 통신을 책임지지 않아야 한다.

## 2단게 : 애플리케이션 서비스 계층 도입

- 도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러 (humble controller, 육각형 아키텍처 분류상 애플리케이션 서비스) 로 책임을 옮겨야 한다.
- 일반적으로 도메인 클래스는 다른 도메인 클래스나 단순 값과 같은 프로세스 내부 의존성에만 의존해야 한다.
- 애플리케이션 서비스의 역할은 복잡도나 도메인 유의성의 로직이 아니라 오케스트레이션만 해당한다.

## 3단계 : 애플리케이션 서비스 복잡도 낮추기

- 재구성 로직(Reconstitution Logic) 이 단순해 보이더라도 실제로는 내부적으로 많은 분기(branch)가 숨어 있어서 테스트할 가치가 있다

## 4단계 : 새 Company 클래스 소개

- tell don't ask 원칙

# 최적의 단위 테스트 커버리지 분석

비즈니스 로직과 오케스트레이션을 완전히 분리하면 코드베이스의 어느 부분을 테스트 단위로 할지 쉽게 결정할 수 있다.

## 도메인 계층과 유틸리티 코드 테스트하기

코드의 복잡도나 도메인 유의성이 높으면 회귀 방지가 뛰어나고 협력자가 거의 없어 유지비도 가장 낮다.

## 나머지 세 사분면에 대한 코드 테스트하기

- 좌측 하단 (간단한 코드): 너무 단순한 코드 (예: 생성자) → 단위 테스트 불필요
- 우측 상단 (지나치게 복잡한 코드): 원래 복잡했지만 리팩터링으로 제거됨 → 테스트할 코드 없음
- 우측 하단 (컨트롤러): 컨트롤러 계층 → 단위 테스트보다 다른 접근 필요 (다음 장에서 설명)

남은 테스트 대상은 도메인 모델(비즈니스 규칙, 도메인 모델 및 알고리즘) 같은 복잡도는 중간 이상이고 협력자 수가 적은 코드(좌측 상단 사분면).  
즉, 도메인 유의성이 있는 복잡한 로직에 집중하는게 가치 있는 단위 테스트이다.

## 전제 조건을 테스트해야 하는가?

일반적으로 권장하는 지침은 도메인 유의성이 있는 모든 전제 조건을 테스트하라는 것이다.

- 테스트해야 할 전제 조건
  - 도메인 규칙과 직접 연결
  - 불변성(Invariant)을 보장
  - 위반 시 비즈니스적으로 큰 문제가 됨
- 테스트하지 않아도 되는 전제 조건
  - 단순 방어 로직, 기술적 안전장치
  - 비즈니스 규칙과 무관
  - 예외 발생으로 충분히 처리 가능

# 컨트롤러에서 조건부 로직 처리

비즈니스 로직과 오케스트레이션의 분리는 다음과 같이 비즈니스 연산이 세 단계로 있을 때 가장 효과적이다.

- 저장소에서 데이터 검색
  - 데이터베이스나 외부 시스템에서 현재 상태를 읽어 온다.
  - 이 과정은 비즈니스 로직이 아니라, 오케스트레이션 책임이다.
- 비즈니스 로직 실행
  - 가져온 데이터를 바탕으로 규칙과 제약 조건을 검증하고, 계산을 수행한다.
  - 이 부분이 도메인의 핵심이다.
- 데이터를 다시 저장소에 저장
  - 변경된 결과를 저장한다.
  - 이것도 비즈니스 로직이 아닌, 인프라스트럭처 책임이다.

## 하지만 이렇게 단계가 명확하지 않은 경우가 많다.

ex, 비즈니스 연산 중에 프로세스 외부 의존성을 참조해야 하는 경우 육각형 아키텍처가 제대로 작동하지 않는다. 이러한 상황에서는 다음과 같이 세 가지 방법이 있다.

### 컨트롤러 단순성

외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기

- 어쨌든 외부에 대한 모든 읽기와 쓰기를 가장자리로 밀어낸다. 이 방법은 '읽고-결정하고-실행하기' 구조를 유지하지만 성능이 저하된다.
- 필요 없는 경우에도 컨트롤러가 프로세스 외부 의존성을 호출한다.
- 컨트롤러를 계속 단순하게 하고 프로세스 외부 의존성과 도메인 모델을 분리하지만(그래서 테스트할 수 있도록 하지만), 성능이 저하된다.

### 도메인 모델 테스트 유의성

도메인 모델에 프로세스 외부 의존성 주입하기

- 도메인 모델에 프로세스 외부 의존성을 주입하고 비즈니스 로직이 해당 의존성을 호출할 시점을 직접 결정할 수 있게 한다.
- 성능을 유지하면서 컨트롤러를 단순하게 하지만, 도메인 모델의 테스트 유의성이 떨어진다.

### 성능

의사 결정 프로새스 단계를 더 세분화하기

- 의사 결정 프로세스 단계를 더 세분화하고, 각 단계별로 컨트롤러를 실행하도록 한다.
- 성능과 도메인 모델 테스트 유의성에 도움을 주지만, 컨트롤러가 단순하지 않다.
- 이러한 세부 단계를 관리하려면 컨트롤러에 의사 결정 지점이 있어야 한다.

문제는 다음 세 가지 특성의 균형을 맞추는 것이다.

- 도메인 모델 테스트 유의성 : 도메인 클래스의 협력자 수와 유형에 따른 함수
- 컨트롤러 단순성 : 의사 결정(분기) 지점이 있는지에 따라 다름
- 성능 : 프로세스 외부 의존성에 대한 호출 수로 정의

위에서 언급한 방법은 세 가지 특성 중 두 가지 특성만 갖는다. 컨트롤러 단순성, 도메인 모델 테스트 유의성, 성능이라는 세 가지 특성을 모두 충족하는 해법은 없다. 따라서 세 가지 중 두 가지를 선택해야 한다.

| 전략               | 도메인 모델 테스트 유의성 | 컨트롤러 단순성 | 성능 |
|------------------|----------------|----------|----|
| 외부 접근 가장자리로 밀어내기 | 높음             | 높음       | 낮음 |
| 도메인에 외부 의존성 주입   | 낮음             | 높음       | 높음 |
| 프로세스 세분화         | 중간             | 낮음       | 높음 |

대부분의 소프트웨어 프로젝트에서는 성능이 매우 중요하기 때문에 '외부에 대한 읽기 쓰기를 비즈니스 연산 가장자리로 밀어내기'는 고려할 필요가 없다.
'도메인 모델에 프로세스 외부 의존성 주입하기'는 대부분 코드를 지나치게 복잡한 사분면에 넣는다. 이런 코드는 더 이상 비즈니스 로직과 프로세스 외부 의존성과의 통신을 분리하지 않으므로 테스트와 유지 보수가 훨씬 어려워지기 때문에 피하는 것이 좋다. 그러면 '의사 결정 프로세스 단계를 더 세분화하기'만 남게 된다. 이 방식을 쓰면 컨트롤러를 더 복잡하게 만들기 때문에 지나치게 복잡한 사분면에 가까워지게 된다. 그러나 이 문제를 완화할 수 있는 방법이 있다. 컨트롤러를 제외한 모든 복잡도를 고려할 수는 없지만, 그 복잡도를 관리할 수는 있다.

## CanExecute/Execute 패턴

컨트롤러 복잡도가 커지는 것을 완화하는 첫 번째 방법은 CanExecute/Execute 패턴을 사용해 비즈니스 로직이 도메인 모델에서 컨트롤러로 유출되는 것을 방지하는 것이다.

## 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적

도메인 모델을 현재 상태로 만든 단계를 빼기 어려울 때가 있다. 그러나 애플리케이션에서 정확히 무슨 일이 일어나는지 외부 시스템에 알려야 하기 때문에 이러한 단계들을 아는 것이 중요할지도 모른다. 컨트롤러에 이러한 책임도 있으면 더 복잡해진다. 이를 피하려면, 도메인 모델에서 중요한 변경 사항을 추적하고 비즈니스 연산이 완료된 후 해당 변경 사항을 외부 의존성 호출로 변환한다. 도메인 이벤트로 이러한 추적을 구현할 수 있다.

정의. 도메인 이벤트는 애플리케이션 내에서 도메인 전문가에게 중요한 이벤트를 말한다. 도메인 전문가에게는 무엇으로 도메인 이벤트와 일반 이벤트(예: 버튼 클릭)를 구별하는지가 중요하가. 도메인 이벤트는 종종 시스템에서 발생하는 중요한 변경 사항을 외부 애플리케이션에 알리는 데 사용된다.

도메인 이벤트는 이미 일어난 일들을 나타내기 때문에 항상 과거 시제로 명명해야 한다. 도메인 이벤트는 값이다. 둘 다 불변이고, 서로 바꿔서 쓸 수 있다.

# 결론

이번 챕터의 핵심 내용은, 외부 시스템에 대한 애플리케이션의 사이드 이펙트를 추상화 하는 것이다.

- 외부 시스템에 대한 사이드 이펙트 : 애플리케이션이 제어할 수 없는 경계 밖의 모든 것.
- 데이터베이스, 파일 시스템, 외부 API 서버, 메시징 시스(kafka, rabbitMQ 등), 이메일 서버 등에 읽기, 쓰기를 하는 것이 바로 외부 시스템에 대한 사이드 이펙트 이다.

“사이드 이펙트를 추상화한다”의 의미

- 구체적인 외부 호출(사이드 이펙트) 코드를 직접 쓰지 않고, 추상 인터페이스나 도메인 이벤트 등으로 감싸서 비즈니스 로직이 “무엇을” 하는지에 집중하게 만든다.
- 즉,
  - 직접적인 DB 쿼리, HTTP 호출, 파일 저장 같은 코드를 도메인 로직 안에 박아 넣지 않는다.
  - 대신 “인터페이스”, “이벤트”, “포트/어댑터” 등을 사용해 감춘다.
  - 이렇게 하면 도메인 코드는 사이드 이펙트의 구현 세부사항을 모르고, 오직 의도만 표현한다.

외부 시스템에 대한 사이드 이펙트를 추상화한다는 것은, DB, 메시지 버스, 파일 시스템 등 경계 밖 시스템과의 구체적인 상호작용을 비즈니스 로직에서 직접 실행하지 않고, 인터페이스나 이벤트 같은 추상 계층을 두어 감싸는 것이다. 이렇게 하면 도메인은 외부 세부사항과 분리되고, 테스트와 유지보수가 쉬워진다.

- 추상화할 것을 테스트하기보다 추상화를 테스트하는 것이 더 쉽다.

- 잠재적인 파편화가 있더라도 비즈니스 로직을 오케스트레이션에서 분리하는 것은 많은 가치가 있다. 이렇게 분리하면 단위 테스트 프로세스가 크게 간소화 되기 때문이다.

| 구분         | 기준                            | 예시                                                                               | 테스트 가치 | 이유                                                 |
|------------|-------------------------------|----------------------------------------------------------------------------------|--------|----------------------------------------------------|
| **식별 가능**  | **① 클라이언트 목표 중 하나에 직접 연관**    | - `placeOrder()` : 사용자가 주문을 생성하는 메서드<br>- `changePassword()` : 사용자가 비밀번호 변경 요청   | 높음     | 사용자가 실제로 달성하려는 목적과 바로 연결됨. 외부에서 이 동작의 결과를 확인할 수 있음 |
| **식별 가능**  | **② 프로세스 외부 의존성에 사이드 이펙트 발생** | - DB에 레코드 추가/수정/삭제<br>- 메시지 큐에 이벤트 발행<br>- 외부 API 호출                             | 높음     | 외부 시스템의 상태가 변하므로 결과가 외부에서 관찰 가능함                   |
| **식별 불가능** | **사용자 목적과 직접 연관 없음**          | - `calculateDiscount()` : 내부에서만 할인 금액 계산<br>- `normalizeEmail()` : 이메일 문자열 포맷 변경 | 낮음     | 내부 구현 세부 사항일 뿐, 외부에서는 이 동작의 발생 여부나 결과를 직접 알 수 없음   |
| **식별 불가능** | **외부 의존성에 영향 없음**             | - `sortProductsByPrice()` : 메모리 내 데이터만 정렬<br>- `validateInputFormat()` : 단순 값 검증 | 낮음     | 외부 시스템의 상태 변화가 없고, 사용자의 주요 목표와 직접 연결되지 않음          |

# 책에서의 요약

- 코드 복잡도는 코드에서 의사 결정 지점 수에 따라 명시적으로(코드) 그리고 암시적으로(코드가 사용하는 라이브러리) 정의된다.
- 도메인 유의성은 프로젝트의 문제 도메인에 대해 코드가 얼마나 중요한지를 보여준다. 복잡한 코드는 종종 도메인 유의성이 높고 그 반대의 경우도 있지만, 모든 경우에 100% 해당하지는 않는다.
- 복잡한 코드와 도메인 유의성을 갖는 코드는 해당 테스트의 회귀 방지가 뛰어나기 때문에 단위 테스트에서 가장 이롭다.
- 협력자가 많은 코드를 다루는 단위 테스트는 유지비가 많이 든다. 이러한 테스트는 협력자를 예상 상태로 만들고 나서 상태나 상호 작용을 확인하고자 공간을 많이 필요로 한다.
- 모든 제품 코드는 복잡도 또는 도메인 유의성과 협락자 수에 따라 네 가지 유형의 코드로 분류할 수 있다.
  - 도메인 모델 및 알고리즘(복잡도 또는 도메인 유의성이 높음. 협력자가 거의 없음)은 단위 테스트에 대한 노력 대비 가장 이롭다.
  - 간단한 코드(복잡도와 도메인 유의성이 낮은. 협력자가 거의 없음)는 테스트할 가지가 전혀 없다.
  - 컨트롤러(복잡도와 도메인 유의성이 낮음. 협력자가 많음)는 통합 테스트를 통해 간단히 테스트해야 한다.
  - 지나치게 복잡한 코드(복잡도 또는 도메인 유의성이 높음. 협력자가 많음)는 컨트롤러와 복잡한 코드로 분할해야 한다.
- 코드가 중요하거나 복잡할수록 협력자가 적어야 한다.
- 험블 객체 패턴은 해당 코드에서 비즈니스 로직을 별도의 클래스로 추출해 복잡한 코드를 테스트할 수 있는 데 도움이 된다. 그 결과, 나머지 코드는 비즈니스 로직을 둘러싼 얇은 험블 래퍼, 즉 컨트롤러가 된다.
- 육각형 아키텍처와 함수형 아키텍처는 험블 객체 패턴을 구현한다. 육각형 아키텍처는 비즈니스 로직과 프로세스 외부 의존성과의 통신을 분리하도록 한다. 함수형 아키텍처는 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 통신과 비즈니스 로직을 분리한다.
- 코드의 깊이와 너비의 관점에서 비즈니스 로직과 오케스트레이션 책임을 생각하라. 코드는 깊을 수도 있고(복잡하거나 중요함) 넓을 수도 있지만(협력자가 많음), 둘 다는 아니다.
- 도메인 유의성이 있으면 전제 조건을 테스트하고, 그 외의 경우에는 테스트하지 않는다.
- 비즈니스 로직과 오케스트레이션을 분리할 때는 다음과 같이 세 가지 붕요한 특성이 있다.
  - 도메인 모델 테스트 유의성 : 도메인 클래스 내 협력자 수와 유형에 대한 함수
  - 컨트롤러 단순성 : 컨트롤러에 의사 결정 지점이 있는지에 따라 다름
  - 성능 : 프로세스 외부 의존성에 대한 호출 수로 정의
- 항상 세 가지 특성 중 최대 두 가지를 가질 수 있다.
  - 외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기 : 컨트롤러를 단순하게 유지하고 도메인 모델 테스트 유의성을 지키지만, 성능이 저하된다.
  - 도메인 모델에 프로세스 외부 의존성을 주입하기 : 성능을 유지하고 컨트롤러를 단순하게 하지만, 도메인 모델의 테스트 유의성이 떨어진다.
  - 의사 결정 프로세스 단계를 더 세분화하기 : 성능과 도메인 모델 테스트 유의성을 지키지만, 컨트롤러의 단순함을 포기한다.
- 의사 결정 프로세스 단계를 더 세분화하는 것이 장단점을 고려할 때 가장 효과적인 절충이다. 다음 두 가지 패턴을 사용해 컨트롤러 복잡도 증가를 완화할 수 있다.
  - CanExecute/Execute 패턴은 각 do() 메서드에 대해 CanDo() 를 두고, CanDo()가 성공적으로 실행되는 것을 Do() 의 전제 조건으로 한다. 이 패턴은 Do() 전에 CanDo() 를 호출하지 않을 수 없기 때문에 컨트롤러의 의사 결정을 근본적으로 제거한다.
  - 도메인 이벤트는 도메인 모델의 중요한 변경 사항을 추적하고 해당 변경 사항을 프로세스 외부 의존성에 대한 호출로 변환한다. 이 패턴으로 컨트롤러에서 추적에 대한 책임이 없어진다.
- 추상화할 것을 테스트하기보다는 추상화를 테스트하는 것이 더 쉽다. 도메인 이벤트는 프로세스 외부 의존성 호출 위의 추상화에 해당한다. 도메인 클래스의 변경은 데이터 자장소의 향후 수정에 대한 추상화에 해당한다.
