# 통합 테스트를 하는 이유

- 단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 동작하는지 확신할 수 없다.
- 단위 테스트가 비즈니스 로직을 확인하는 데 좋지만, 비즈니스 로직을 외부와 단절된 상태로 확인하는 것만으로는 충분하지 않다.

# 통합 테스트는 무엇인가?

## 통합 테스트의 역할

단위 테스트는 다음 세 가지 요구 사항을 충족하는 테스트다.

- 단일 동작 단위를 검증하고
- 빠르게 수행하고
- 다른 테스트와 별도로 처리한다.

이 세 가지 요구 사항 중 하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속한다.  
단위 테스트가 아닌 모든 테스트가 통합 테스트에 해당한다.

통합 테스트는 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증한다. 다시 말해, 이 테스트는 컨트롤러 사분면에 속하는 코드를 다룬다.

|                 | 협력자 수 ↓      | 협력자수 ↑      |
|-----------------|--------------|-------------|
| 복잡도 및 도메인 유의성 ↑ | 도메인 모델과 알고리즘 | 지나치게 복잡한 코드 |
| 복잡도 및 도메인 유의성 ↓ | 간단한 코드       | 컨트롤러        |

- 단위 테스트 : 도메인 모델과 알고리즘
- 컨트롤러 : 통합 테스트

간단한 코드와 지나치게 복잡한 코드는 전혀 테스트해서는 안 된다.  
컨트롤러 사분면을 다루는 ㅔ스트가 단위 테스트일 수도 있다.  
모든 프로세스 외부 의존성을 목으로 대체하면 테스트 간에 공유하는 의존성이 없어지므로 테스트 속도가 빨라지고 서로 격리될 수 있다.  
그러나 대부분의 애플리케이션은 목으로 대체할 수 없는 프로세스 외부 의존성이 있다. (ex, 데이터베이스)

## 다시 보는 테스트 피라미드

통합 테스트가 프로세스 외부 의존성에 직접 작동하면 느려지며, 이러한 테스트는 유지비가 많이 든다. 유지비 증가의 이유는 다음과 같다.

- 프로세스 외부 의존성 운영이 필요함
- 관련된 협력자가 많아서 테스트가 비대해짐

통합 테스트는 코드를 더 많이 거치므로 회귀 방지가 단위 테스트보다 우수하다. 또한 제품 코드와의 결합도가 낮아서 리팩터링 내성도 우수하다.  
단위 테스트와 통합 테스트의 비율은 프로젝트의 특성에 따라 다를 수 있지만, 일반적인 경험에 비춰본 규칙은 다음과 같다. 단위 테스트로 가능한 한 많이 비즈니스 시나리오의 예외 상황을 확인하고, 통합 테스트는 주요 흐름(happy path)과 단위 테스트가 다루지 못하는 기타 예외 상황(edge case)을 다룬다.  
정의> 주요 흐름(happy path)은 시나리오의 성공적인 실행이다. 예외 상황은 비즈니스 시나리오 수행 중 오류가 발생하는 경우다.

## 통합 테스트와 빠른 실패

이 절에서는 통합 테스트를 사용해 비즈니스 시나리오당 하나의 주요 흐름과 단위 테스트로 처리할 수 없는 모든 예외 상황을 다루는 지침을 자세히 설명한다.

- 통합 테스트: 외부 시스템과의 상호작용을 실제로 확인하는 “긴 주요 흐름”에 집중.
- 단위 테스트: 도메인 로직의 전제 조건, 사전 검증 로직, 빠른 실패 조건 등을 집중적으로 확인.
- 른 실패(Fast Fail): 치명적인 오류를 초기에 발견해, 통합 테스트를 줄이는 효과를 제공.

- 외부 환경이 있어야만 발생하는 예외 → 통합 테스트 필요
- 잘못된 호출 시 바로 터지고 데이터도 안전 → 굳이 통합 테스트 안 해도 됨, 단위 테스트나 첫 실행에서 잡힘

| 예외 상황 유형                        | 설명                                           | 테스트 방법             | 이유                                         |
|---------------------------------|----------------------------------------------|--------------------|--------------------------------------------|
| **단위 테스트에 다룰 수 없는 예외 상황**       | 외부 시스템(DB, API, 파일 등)과 실제 상호작용이 있어야만 발생하는 예외 | 통합 테스트             | 모의(Mock) 객체로 재현이 불가능하고, 실제 환경에서만 발생 가능     |
| **빠른 실패(Fast Fail)로 잡히는 예외 상황** | 잘못된 호출 시 애플리케이션이 즉시 예외를 던지고 멈추며, 데이터 손상 없음   | 단위 테스트 또는 개발 초기 실행 | 첫 실행 시 바로 버그가 드러나고, 복잡한 통합 테스트를 작성할 필요가 없음 |

“즉시 실패하는 예외 상황”은 단위 테스트로 커버하고, 통합 테스트까지 만들 필요는 없다.

# 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

- 통합 테스트는 시스템이 프로세스 외부 의존성과 어떻게 통합하는지를 검증한다.
- 이러한 검증을 구현하는 방식은 두 가지가 있다.
  - 실제 프로세스 외부 의존성을 사용
  - 해당 의존성을 목으로 대체

## 프로세스 외부 의존성의 두 가지 유형

모든 프로세스 외부 의존성은 두 가지 범주로 나뉜다.

### 관리 의존성

전체를 제어할 수 있는 프로세스 외부 의존성

- 이러한 의존성은 애플리케이션을 통해서만 접근할 수 있다.
- 해당 의존성과의 상호 작용은 외부 환경에서 볼 수 없다.
- 대표적인 예로 데이터베이스가 있다.

### 비관리 의존성

전체를 제어할 수 없는 프로세스 외부 의존성

- 해당 의존성과의 상호 작용을 외부에서 볼 수 있다.
- 예를 들어 SMTP 서버와 메시지 버스 등이 있다.

앞서 관리 의존성과의 통신은 구현 세부 사항이라고 했다.
반대로, 비관리 의존성과의 통신은 시스템의 식별할 수 있는 동작이다.

** 관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라.

## 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기

대표적으로, 다른 애플리케이션이 접근할 수 있는 데이터베이스
이런 경우 다른 애플리케이션에서 볼 수 있는 테이블을 비관리 의존성으로 취급하라.
통합 테스트에서 목으로 대체한다.
나머지 데이터베이스는 관리 의존성으로 취급하라.
상호 작용이 아닌 최종 상태를 검증하라.

## 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?

관리 의존성임에도 불구하고 데이터베이스를 목으로 대체하면 통합 테스트의 리팩터링 내성이 저하된다.
이렇게 하면 테스트는 회귀 방지로 떨어진다.

# 통합 테스트: 예제

- 통합 테스트에 대한 일반적인 지침은 가장 긴 주요 흐름과 단위 테스트로는 수행할 수 없는 모든 예외 상황을 다루는 것이다.
- 가장 긴 주요 흐름은 모든 프로세스 외부 의존성을 거치는 것이다.

# 의존성 추상화를 위한 인터페이스 사용

- 단위 테스트 영역에서 개발자들이 가장 많이 오해하는 주제 중 하나가 인터페이스 사용이다.

## 인터페이스와 느슨한 결합

- 많은 개발자가 데이터베이스나 메시지 버스와 같은 프로세스 외부 의존성을 위해 인터페이스를 도입한다.
- 심지어 인터페이스 구현이 하나만 있는 경우에도 그렇다.
- 이 관습이 널리 퍼져 있어서 아무도 의문을 제기하지 않는다.

다음과 같은 경우를 흔히 볼 수 있다.

```
public interface IMessageBus
public class MessageBus : IMessageBus

public interface IUserRepository
public class UserRepository : IUserRepository
```

- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고
- 기존 코드를 변경하지 않고 새로운 기능을 추가해 개방 폐쇄 원칙(OCP, Open Closed Principle) 을 지키기 때문이다.

이 두가지 이유 모두 오해다.
단일 구현을 위한 인터페이스는 추상화가 아니다.
해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다.
진정한 추상화는 발경하는 것이지, 발명하는 것이 아니다.
의미상 추상화가 이미 존재하지만 코드에서 아직 명확하게 정의되지 않았을 때 그 이후에 발견되는 것이다.
인터페이스가 진정으로 추상화되려면 구현이 적어도 두 가지는 있어야 한다.

YAGNI (You aren't gonna need it) 를 위반 한다.
YAGNI 는 현재 필요하지 않은 기능에 시간을 들이지 말라는 것이다.

## 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

간단히 말하자면 목(mock)을 사용하기 위함이다.
인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.
따라서 이러한 의존성을 목(mock)으로 처리할 필요가 없는 한, 프로세스 외부 의존성에 대한 인터페이스를 두지 말라.
비관리 의존성만 목(mock)으로 처리하므로, 결국 비관리 의존성에 대해서만 인터페이스를 쓰라는 지침이 된다.
관리 의존성을 컨트롤러에 명시적으로 주입하고, 해당 의존성을 구체 클래스로 사용하라.

# 통합 테스트 모범 사례

통합 테스트를 최대한 활용하는 데 도움이 되는 몇 가지 일반적인 지침이 있다.

- 도메인 모델 경계 명시하기
- 애플리케이션 내 계층 줄이기
- 순환 의존성 제거하기

## 도메인 모델 경계 명시하기

- 도메인 모델은 프로젝트가 해결하고자 하는 문제에 대한 도메인 지식의 모음이다.
- 단위 테스트는 도메인 모델과 알고리즘을 대상으로 하고, 통합 테스트는 컨트롤러를 대상으로 한다.
- 모든 도메인 로직이 하나의 뚜렷한 우산 아래에 있고 코드베이스 여기저기에 흩어져있지 않는 한, 그 세부 사항은 그다지 중요하지 않다.

## 애플리케이션 내 계층 줄이기

- 애플리케이션에 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기가 너무 어려워진다.
- 대부분의 백엔스 시스템에서는 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층, 이 세 가지만 활용하면 된다.
- 인프라 계층은 보통 도메인 모델에 속하지 않는 알고리즘과 프로세스 외부 의존성에 접근할 수 있는 코드로 구성된다.
- 도메인 계층(도메인 로직 포함), 애플리케이션 서비스 계층(외부 클라이언트에 대한 진입점 제공 및 도메인 클래스와 프로세스 외부 의존성 간의 작업 조정), 인프라 계층(데이터베이스 저장소나 ORM 매핑, SMTP 게이트웨이 등이 이 계층에 있고, 프로세스 외부 의존성과 작동함). 이 세 가지 계층만 활용하면 된다.

## 순환 의존성 제거하기

- 순환 의존성 (circular dependency 또는 cyclic dependency) 은 둘 이상의 클래스가 제대로 작동하고자 직간접적으로 서로 의존하는 것을 말한다.
- 순환 의존서의 대표적인 예는 콜백(callback) 이다.
- 추상 계층이 너무 많은 것과 마찬가지로, 순환 의존성은 코드를 읽고 이해하려고 할 때 알아야 할 것이 많아서 큰 부담이 된다.
- 순환 의존성을 처리하는 더 좋은 방법은 순환 의존성을 제거하는 것이다.
- 코드베이스에서 순환 의존성을 모두 제거하는 것은 거의 불가능하가.
- 설령 그렇더라도 서로 의존적인 클래스의 그래프를 가능한 한 작게 만들면 손상을 최소화할 수 있다.

## 테스트에서 다중 실행 구절 사용

- 테스트에서 두 개 이상의 준비나 실행 또는 검증 구절을 두는 것은 '코드 악취(code smell)' 에 해당한다.
- 이는 테스트가 여러 가지 동작 단위를 확인해서 테스트 유지 보수성을 저해한다는 신호다.
- 둘 이상의 실행 구절로 테스트를 작성하는 것이 타당한 이유를 생각해보면, 프로세스 외부 의존성을 관리하기 어려운 경우뿐이다.
- 단위 테스트는 프로새스 외부 의존성으로 작동하지 않기 때문에 절대로 실행 구절이 여러 개 있어서는 안 된다.

# 로깅 기능을 테스트하는 방법

## 로깅을 테스트해야 하는가?

- 로깅을 테스트해야 하는지를 묻는 질문에 대한 댑은 다음과 같다.
- 로깅이 애플리케이션의 식별할 수 있는 동작인가? 아니면 구현 세부 사항인가?
- 보는 이가 개발자뿐이라면, 아무도 모르게 자유로이 수정할 수 있는 구현 세부 사항이므로 테스트해서는 안 된다.
- Steve Freeman 과 Nat Pryce 의 Growing Object-Oriented Software, Guided by Tests 에서는 다음과 같이 두 가지 유형의 로깅으로 나눈다.
  - 지원 로깅 (support logging) 은 지원 담당자나 시스템 관리자가 추적할 수 있는 메시지를 생성한다.
  - 진단 로깅 (diagnostic logging) 은 개발자가 애플리케이션 내부 상황을 파악할 수 있도록 돕는다.

# 결론

식별할 수 있는 동작인지, 아니면 구현 세부사항인지 여부에 대한 관점으로 프로세스 외부 의존성과의 통신을 살펴보자.
로그 저장소도 그런 면에서 전혀 다르지 않다.
개발자가 아닌 사람이 로그를 볼 수 있으면 로깅 기능을 목으로 처리하고, 그렇지 않으면 테스트하지 말라.

# 책에서의 요약

- 통합 테스트는 단위 테스트가 아닌 테스트에 해당한다. 통합 테스트는 시스템이 프로세스 외부 의존성과 통합해 작동하는 방식을 검증한다.
  - 통합 테스트는 컨트롤러를 다루고, 단위 테스트는 알고리즘과 도메인 모델을 다룬다.
  - 통합 테스트는 회귀 방지와 리팩터링 내성이 우수하고, 단위 테스트는 유지 보수성과 피드백 속도가 우수하다.
- 통합 테스트의 기준은 단위 테스트보다 놆다. 통합 테스트에서 회귀 방지와 리팩터링 내성 지표에 대한 점수는 단위 테스트보다 유지 보수성과 피드백 속도가 떨어진 만큼은 높아야 한다. 테스트 피라미드가 이러한 절충을 나타낸다. 대부분의 테스트는 빵르면서 비용이 낮아야 하고, 시스템이 전체적으로 올바른지 확인하는 통합 테스트는 속도가 느리고 비용이 많이 발생하므로 그 수가 적어야 한다.
  - 단위 테스트를 통해 가능한 한 많은 비즈니스 시나리오의 예외 상황을 확인하라. 통합 테스트를 사용해서 하나의 주요 흐름과 단위 테스트로 확인할 수 없는 예외 상황을 다루도록 하라.
  - 테스트 프라미드의 모양은 프로젝트 복잡도에 따라 달라진다. 간단한 프로젝트는 도메인 모델에 코드가 거의 없으므로 단위 테스트와 통합 테스트의 개수가 동일하다. 아주 단순한 경우 단위 테스트가 없을 수도 있다.
- 빠른 실패 원칙은 버그가 빠르게 나타날 수 있도록 하며 통합 테스트에서 할 수 있는 대안이다.
- 관리 의존성은 애플리케이션을 통해서만 접ㄱ근할 수 있는 프로세스 외부 의존성이다. 관리 의존성과의 상호 작용은 외부에서 관찰할 수 없다. 대표적인 예는 애플리케이션 데이터베이스다.
- 비관리 의존성은 다른 애플리케이션이 접근할 수 있는 프로세스 외부 의존성이다. 비관리 의존성과의 상호 작용은 외부에서 관찰할 수 있다. 대표적인 예로 SMTP 서버나 메시지 버스 등이 있다.
- 관리 의존성과의 통신은 구현 세부 사항이고, 비관리 의존성과의 통신은 식별할 수 있는 동작이다.
- 통합 테스트에서 간리 의존성은 실제 인스턴스를 사용하라. 비관리 의존성은 목으로 대체하라.
- 때로는 관리 의존성과 비관리 의존성 모두의 특성을 나타내는 프로세스 외부 의존성이 있다. 전형적인 예로는 다른 애플리케이션이 접근할 수 있는 데이터베이스가 있다. 비관리 의존성의 식별 가능한 부분을 비관히 의종성으로 간주하고, 테스트에서 해당 부분을 목으로 대체하라. 나머지 부분을 관리 의존성으로 간주하고, 해당 부분과의 상호 작용 대신 최종 상태를 검증하라.
- 통합 테스트에서 관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라.
- 때때로 프로레스 외부 의존성은 관리 의존성과 비관리 의존성 모두의 속성으 나타낸다. 대표적인 예로 다른 애플리케이션이 접근할 수 있는 데이터베이스가 있다. 의존성 중 관찰할 수 있는 부분을 비관리 의존성으로 취급하라. 즉, 테스트에서 해당 부분을 목으로 대체하라. 나머지 의존성은 관리 의존성으로 취급하라. 상호 작용이 아닌 최종 상태를 검증하라.
- 통합 테스트는 관리 의존성과 작동하는 모든 계층을 거쳐야 한다. 데이터베이스를 예로 들면, 입력 매개변수로 사용한 데이터와 별개로 해당 데이터배이스의 상태를 확인하는 것을 의미한다.
- 구현이 하나뿐인 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다. 이러한 인터페이스에 대한 향후 구현을 예상하면 YAGNI 법칙을 위배한다.
- 구현이 하나뿐인 인터페이스를 사용하기에 타당한 이유는 목을 사용하기 위한 것뿐이다. 비관리 의존성에만 사용하고, 관리 의존성은 구체 클래스를 사용하라.
- 프로세스 내부 의존성에 대해 구현이 하나뿐인 인터페이스는 좋지 않다. 이러한 인터페이스는 목을 사용해 도메인 클래스 간의 상호 작용을 확인하게 되고, 테스트가 코드의 구현 세부 사항에 결합된다.
- 도메인 모델을 코드베이스에 명시적이고 잘 알려진 위치에 둬라. 도메인 클래스와 컨트롤러 사이의 경계가 명확하면 단위 테스트와 통합 테스트를 좀 더 쉽게 구분할 수 있다.
- 간접 계층이 너무 많으면 코드를 추론하기가 어려워진다. 간접 계층을 가능한 한 적게 하라. 대부분의 백엔드 시스템은 도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층, 이 세 가지 계층만 있다.
- 순환 의존성이 있으면 코드를 이해하려고 할 때 알아야 하는 부담이 커진다. 대표적인 예는 콜백(수신자가 발신자에게 작업 결과를 알리는 경우)이다. 값 객체를 도입해 순환을 없애고, 호출부에 주는 결과를 값 객체로 반환하라.
- 테스트에 여러 실행 구절이 있는 것은 올바른 상태가 되기 어려운 프로세스 외부 의존성으로 작동하는 경우에만 타당하다. 단위 테스트는 프로세스 외부 의존성으로 수행되지 않기 때문에 여러 가지 실행을 해서는 안 된다. 다단계 테스트는 대부분 엔드 투 엔드 테스트 범주에 속한다.
- 지원 로깅은 지원 부서나 시스템 관리자를 위한 것이며, 애플리케이션의 식별할 수 있는 동작이다. 진단 로깅은 개발자가 애플리이션 내부에서 진행되는 작업을 이해하는 데 두음을 주며, 구현 세부 사항이다.
- 지원 로깅은 비즈니스 요구 사항이므로 해당 요구 사항을 코드베이스에 명시적으로 반영하라. 비즈니스에 팔요한 모든 지원 로깅이 나열돼 있는 특별한 DomainLogger 클래스를 도입히라.
- 지원 로깅을 프로세스 외부 의존성으로 작동하는 다른 기능처럼 취급하라. 도메인 이벤트를 사용해 도메인 모델의 변경 사항을 추적하라. 컨트롤러에서 도메인 이벤트를 DomainLogger 호출로 변환하라.
- 진단 로깅을 테스트하지 말라. 지원 로길과 달리 도메인 모델에서 직접 진단 로그를 남길 수도 있다.
- 진단 로깅은 가끔 사용하라. 진단 로깅을 너무 많이 쓰면 코드를 복잡하게 하고 로그의 신호 대비 잡음 비율이 나빠진다. 이상적으로는 진단 로깅을 처리되지 않은 예외에 대해서만 사용해야 한다.
- 항상 모든 의존성(로거 포함)을 생성자 또는 메서드 인수를 통해 명시적으로 주입하라.
