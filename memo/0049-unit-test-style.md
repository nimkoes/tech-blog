# 단위 테스트의 세 가지 스타일

- 출력 기반 (output-based testing)
  - 가장 품질이 좋다.
  - 아무데서나 사용할 수 없으며, 순수 함수 방식으로 작성된 코드에만 적용된다.
  - 이를 위해 함수형 프로그래밍 원칙을 사용해 기반 코드가 함수형 아키텍처를 지향하게끔 재구성해야 한다.
- 상태 기반 (state-based testing)
  - 두 번째로 좋은 선택이다.
- 통신 기반 (communication-based testing)
  - 간헐적으로만 사용 해야 한다.

- 하나의 테스트에서 하나 또는 둘, 심지어 세 가지 스타일 모두를 함께 사용할 수 있다.

## 출력 기반 테스트 스타일 정의

- 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식이다.
- 이러한 단위 테스트 스타일은 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.
- 시스템이 생성하는 출력을 검증한다.
- 사이드 이펙트가 없고 SUT 작업 결과는 호출자에게 반환하는 값뿐이다.
- 출력 기반 단위 테스트 스타일은 함수형(functional)이라고도 한다.

- (-> 간단한 java 예제 테스트 코드가 있으면 좋겠다.)

## 상태 기반 테스트 스타일 정의

- 작업이 완료된 후 시스템 상태를 확인하는 것이다.
- 상태라는 용어는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.

- (-> 간단한 java 예제 테스트 코드가 있으면 좋겠다.)

## 통신 기반 테스트 스타일 정의

- 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.
- SUT의 협력자는 목으로 대체하고 SUT가 협력자를 올바르게 호출하는지 검증한다.

- (-> 간단한 java 예제 테스트 코드가 있으면 좋겠다.)

단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 런던파는 이와 반대로 선택한다. 두 분파는 출력 기반 테스트를 사용한다.

# 단위 테스트 스타일 비교

- 좋은 단위 테스트의 4대 요소로 서로 비교해본다.
- 4대 요소는 다음과 같다.
  - 회귀 방지
  - 리팩터링 내성
  - 빠른 피드백
  - 유지 보수성

## 회귀 방지와 피드백 속도 지표로 스타일 비교하기

- 회귀방지력이란, 코드를 변경했을 때 그 변경으로 인해 발생한 문제(=버그)를 테스트가 잘 잡아낸다는 뜻이다.
- 회귀 방지 지표는 특정 스타일에 따라 달라지지 않는다.
- 회귀 방지 지표는 다음의 세 가지 특성으로 결정 된다.

### 테스트 중에 실행되는 코드의 양

- 테스트가 실행될 때 실제로 얼마나 많은 프로덕션 코드가 실행되느냐를 말한다.
- 테스트가 특정 메서드만 호출하는 게 아니라, 내부적으로 다른 많은 메서드를 같이 호출한다면 테스트 중에 실행되는 코드의 양이 많은 것이다.
- 실행되는 코드가 많다는 건 변경이 다른 곳에 영향을 미칠 확률도 높고, 그만큼 테스트가 많은 부분의 변경을 감지할 수 있다는 뜻이다.
- 반대로 코드의 한 부분만 실행한다면, 다른 부분의 변화는 감지하지 못하게 된다.
  ```java
  class OrderService {
      public int calculateTotal(Order order) {
          return order.getQuantity() * order.getUnitPrice();
      }
  }
      
  class Order {
      private int quantity;
      private int unitPrice;
      
      public Order(int quantity, int unitPrice) {
          this.quantity = quantity;
          this.unitPrice = unitPrice;
      }
      
      public int getQuantity() {
          return quantity;
      }
      
      public int getUnitPrice() {
          return unitPrice;
      }
  }
  ```
  ```java
  @Test
  void calculateTotal_shouldMultiplyQuantityAndUnitPrice() {
      Order order = new Order(2, 100); // 수량 2, 단가 100
      OrderService service = new OrderService();
      
      int total = service.calculateTotal(order);
      
      assertEquals(200, total);
  }
  ```
- 이 테스트는 OrderService.calculateTotal() 뿐만 아니라 Order.getQuantity(), Order.getUnitPrice()도 실행한다.
- 즉, 단순한 테스트처럼 보여도 세 개의 메서드가 실행되고 있는 것이다

### 코드 복잡도

- 해당 테스트가 커버하는 코드의 복잡성(예: if, switch, loop 등의 분기 처리) 이 얼마나 되느냐이다.
- 코드가 복잡할수록 테스트의 회귀 방지 효과는 커진다.
- 왜냐하면 복잡한 분기 구조는 변경에 더 취약하기 때문이다.
- 테스트가 복잡한 분기 조건을 커버하지 않는다면, 테스트는 변경 감지 능력이 낮다.
- 반대로 다양한 조건과 흐름을 포함한 코드를 테스트하면, 작게 바뀌는 것도 감지할 수 있어 회귀 방지가 잘 된다.
  ```java
  class DiscountService {
      public int calculateDiscount(int price) {
          if (price > 1000) {
              return 100;
          } else if (price > 500) {
              return 50;
          } else {
              return 0;
          }
      }
  }
  ```
  ```java
  @Test
  void discount_shouldBe100_ifPriceAbove1000() {
      DiscountService service = new DiscountService();
      assertEquals(100, service.calculateDiscount(1500)); // 조건 1
  }
      
  @Test
  void discount_shouldBe50_ifPriceBetween500And1000() {
      DiscountService service = new DiscountService();
      assertEquals(50, service.calculateDiscount(700)); // 조건 2
  }
      
  @Test
  void discount_shouldBe0_ifPriceBelow500() {
      DiscountService service = new DiscountService();
      assertEquals(0, service.calculateDiscount(300)); // 조건 3
  }
  ```
- 이 테스트는 코드의 if, else if, else 3개의 분기를 모두 커버한다.
- 즉, 복잡한 코드 흐름을 테스트하고 있기 때문에 회귀 방지력이 높다.

### 도메인 유의성

- 테스트가 검증하는 것이 실제 비즈니스 요구사항(=도메인 로직)과 얼마나 관련성이 있느냐를 의미한다.
- 도메인 유의성이 높다는 것은, 이 테스트가 실제로 중요한 기능을 검증하고 있다는 뜻이다.
- 테스트가 내부 구현 방식만 확인하거나 너무 기술적인 세부사항만 확인하면, 실제 기능과 동떨어진 “겉핥기 테스트”가 된다. 이런 테스트는 회귀를 막는 데 큰 도움이 되지 않는다.
- 도메인 유의성이 높은 테스트는 실제 고객이나 사용자의 요구사항을 보호해준다.
  ```java
  class BankAccount {
      private int balance;
      
      public BankAccount(int balance) {
          this.balance = balance;
      }
      
      public void withdraw(int amount) {
          if (amount > balance) throw new IllegalArgumentException("Insufficient balance");
          balance -= amount;
      }
      
      public int getBalance() {
          return balance;
      }
  }
  ```
  ```java
  @Test
  void withdraw_shouldReduceBalance() {
  BankAccount account = new BankAccount(1000);
      account.withdraw(200);
      
      assertEquals(800, account.getBalance()); // 중요한 도메인 로직 확인
  }
      
  @Test
  void withdraw_shouldFail_ifInsufficientBalance() {
      BankAccount account = new BankAccount(100);
      
      assertThrows(IllegalArgumentException.class, () -> {
          account.withdraw(200); // 도메인 규칙 위반 시 예외 발생 검증
      });
  }
  ```
- 이 테스트는 실제 은행 계좌 출금이라는 중요한 비즈니스 규칙을 검증하고 있다. 즉, 도메인 유의성이 매우 높다.
- 이런 테스트는 변경이 발생했을 때 핵심 요구사항이 깨지는 걸 빠르게 감지할 수 있다.


- 테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다.
- 테스트가 프로새스 외부 의존성과 떨어져 단위 테스트 영역에 있는 한, 모든 스타일은 테스트 실행 속도가 거의 동일하다.

## 리팩터링 내성 지표로 스타일 비교하기

- 리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성(허위 경보) 수에 대한 척도다.
- 결국 거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과다.

### 출력 기반 테스트

- 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다.
- 이러한 테스트가 구현 세부 사항에 결합하는 경우는 테스트 대상 메서드가 구현 세부 사항일 때뿐이다.

### 상태 기반 테스트

- 일반적으로 거짓 양성이 되기 쉽다.
- 테스트 대상 메서드 외에도 클래스 상태와 함께 작동한다.

### 통신 기반 테스트

- 거짓 양성에 가장 취약하다.
- 스텁과의 상호 작용을 확인해서는 안 된다.
- 애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮다.


- 캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.

## 유지 보수성 지표로 스타일 비교하기

- 유지 보수성은 단위 테스트의 유지비를 특정하며, 다음 두 가지 특성으로 정의 한다.
  - 테스트를 이해하기얼마나 어려운가(테스트 크기에 대한 함수)?
  - 테스트를 실행하기 얼마나 어려운가(테스트에 직접적으로 관련 있는 프로세스 외부 의존성 개수에 대한 함수)?

### 출력 기반 테스트의 유지 보수성

- 다른 두 가지 스타일과 비교하면, 출력 기반 테스트가 가장 유지 보수하기 용이하다.

### 상태 기반 테스트의 유지 보수성

- 헬퍼 메서드 사용과 값 객체로 클래스 변환하기는 가끔만 적용할 수 있다.

### 통신 기반 테스트의 유지 보수성

- 출력 기반 테스트와 상태 기반 테스트보다 유지 보수성 점수가 낮다.

## 스타일 비교하기 결론

|                        | 출력 기반 | 상태 기반 | 통신 기반 |
|------------------------|-------|-------|-------|
| 리팩터링 내성을 지키기 위해 필요한 노력 | 낮음    | 중간    | 중간    |
| 낮음                     | 중간    | 높음    |

- 세가지 스타일 모두가 회귀 방지와 피드백 속도 지표에서는 점수가 같다.
- 출력 기반 스타일은 함수형으로 작성된 코드애만 적용할 수 있다.
- 코드를 순수 람수로 만들면 상태 기반 테스트나 통신 기반 테스트 대신 출력 기반 테스트가 가능해진다.

# 함수형 아키텍처 이해

## 함수형 프로그래밍이란?

- 출력 기반 단위 테스트 스타일은 함수형이라고도 한다.
- 입출력 모두 메서드 시그니처에 명시되어 있으면 수학적 함수가 된다.
- 숨은 입출력이 없는 메서드는 수학에서 말하는 함수의 정의를 준수하기 때문에 수학적 함수라고 한다.
- 숨은 입출력의 유형
  - 사이드 이펙트
    - 메서드 시그니터에 표시되지 않은 출력이며, 따라서 숨어 있다.
    - 연산은 클래스 인스턴스의 상태를 변경하고 디스크의 파일을 업게이트하는 등 사이드 이펙트를 발생시킨다.
  - 예외
    - 메서드가 예외를 던지면, 프로그램 흐름에 메서드 시그니처에 설정된 계약을 우회하는 경로를 만든다.
    - 호출된 예외는 호출 스택의 어느 곳에서도 발생할 수 있으므로, 메서드 시그니처가 전달하지 안은 출력을 추가한다.
  - 내외부 상태에 대한 참조
    - DateTime.now() 와 같이 정적 속성응 사용해 현재 날짜와 시간을 가져오는 메서드가 있을 수 있다.
    - 데이터베이스에서 데이터를 질의할 수 있고, 비공개 변경 가능 필드를 참조할 수도 있다.
    - 이 모두 메서드 시그니처에 없는 실행 흐름에 대한 입력이며, 따라서  숨어있다.
  - 메서드가 수학적 함수인지 판별하는 가장 좋은 방법은 프로그램의 동작을 변경하지 않고 해당 메서드에 대한 호출을 반환 값으로 개체할 수 있는지 확인하는 것이따.
  - 메서드 호출을 해당 값으로 바꾸는 것을 참조 투명성(referential transparency)이라고 한다.

## 함수형 아키텍처란?

- 함수형 프로그래밍의 목표는 사이드 이펙트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하느느 코드와 사이드 아펙트를 일으키는 코드를 분리하는 것이다.
- 함수형 아키텍처는 사이드 이펙트를 다루는 코드를 최소화하면서 순수 함수(불변) 반식으로 작성한 코드의 양을 극대화 한다. '불변(immutable)'이란 변하지 않는 것을 의미한다.
- 일단 객체가 생성되면 그 상태는 바꿀 수 없다. 이는 생성 후 수정할 수 있는 변경 가능한(mutable) 객체와 대조적이다.
- 다음 두 가지 코드 유형을 구분해서 비즈니스 로직과 사이드 이펙트를 분리할 수 있다.
  - 결정을 내리는 코드
    - 이 코드느 사이드 이펙트가 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
  - 해당 결정에 따라 작용하는 코드
    - 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.
- 결정을 내리는 코드는 종종 함수형 코어(functional core, 불변 코어 immutable core) 라고도 한다.
- 해당 결정에 따라 작용하는 코드는 가변 셸(mutable shell) 이다,

- 함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.
  - 가변 셸은 모든 입력을 수집한다.
  - 함수형 코어는 결정을 생성한다.
  - 셸은 결정을 사이드 이펙트로 변환한다.
- 목표는 출력 기반 테스트로 함수형 코어를 두루 다루고, 가변 셸을 훨씬 더 적은 수의 통합 테스트에 맡기는 것이다.
- 마이클 페더스(Michael Feathers)
  - Object-oriented programming makes code understandable by encapsulating moving parts. Functional programming makes code understandable by minimizing moving parts.

## 함수형 아키텍처와 육각형 아키텍처 비교

- 유사점
  - 둘 다 관심사 분리라는 아이디어를 기반으로 한다.
  - 육각형 아키택처에서 도메인 계층 내 클래스는 서로에게만 의존해야 한다.
  - 함수형 아키텍처의 불변 코어는 가변 셸에 의존하지 않는다.
    - 가변 셸에서 불변 코어를 완전히 떼어내 셸이 제공하는 입력을 단순한 값으로 모방할 수 있다.
- 차이점
  - 함수형 아키텍처는 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다. 이 가장자리는 가변 셸이 처리한다.
  - 육각형 아키텍처는 도메인 계층에 제한하는 한, 도메인 계층으로 인한 사이드 이펙트도 문제없다.
  - 육각형 아키텍처의 모든 수정 사항은 도메인 계층 내에 있어야 하며, 계층의 경계를 넘어서는 안 된다.
- 함수형 아키텍처는 육각형 아키텍처의 하위 집합이다. 극단적으로는 함수형 아키텍처를 육각형 아키텓처로 볼 수도 있다.

# 함수형 아키텍처와 출력 기반 테스트로의 전환

- 함수형 아키텍처로 리팩터링하는 두 가지 단계
  - 프로세스 외부 의존성애서 목으로 변경
  - 목에서 함수형 아키텍처로 변경

# 책에서의 요약

- 출력 기반 테스트는 SUT에 입력을 주고 출력을 확인하는 테스트 스타일이다. 이 테스트 스타일은 숨은 입출력이 없다고 가정하고, SUT 작업의 결과는 반환하는 값뿐이다.
- 상태 기반 테스트는 작업이 완료된 후의 시스템 상태를 확인한다.
- 통신 기반 테스트는 목을 사용해서 테스트 대상 시스템과 협력자 간의 통신을 검증 한다.
- 단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 던전파는 반대를 선호한다. 두 분파 모두 출력 기반 테스트를 사용한다.
- 출력 기반 테스트가 테스트 품질이 가장 좋다. 이러한 테스트는 구현 세부 사항에 거의 결합되지 않으므로 리팩터링 내성이 있다. 또한 작고 간결하므로 유지 보수하기도 쉽다.
- 상태 기반 테스트는 안정성을 위해 더 신증해야 한다. 단위 테스트를 하려면 비공개 상태를 노출하지 않도록 해야 한다. 상태 기반 테스트는 출력 기반 테스트보다 크기가 큰 편이므로 유지 보수가 쉽지 않다. 헬퍼 메서드와 값 객체를 사용해 유지 보수성 문제를 완화할 수도 있지만 제거할 수는 없다.
- 통신 기반 테스트도 안정성을 위해 더 신중해야 한다. 애플리케이션 경계를 넘어서 외부 환경에 사이드 이펙트가 보이는 통신만 확인해야 한다. 통신 기반 테스트의 유지 보수성은 출력 기반 테스트 및 상태 기반 테스트와 비교할 때 좋지 않다. 목은 공간을 많이 차지하는 경향이 있어서 테스트 가독성이 떨어진다.
- 함수형 프로그래밍은 수학적 함수로 된 프로그래밍이다.
- 수학적 삼수는 숨은 입출력이 없는 함수(또는 메서드)다. 사이드 이펙트와 예외가 숨은 출력에 해당한다. 내부 상태 또는 외부 상태에 대한 참조는 숨은 입력이다. 수학적 함수는 명시적이므로 테스트 용이성을 상당히 높인다.
- 함수형 프로그래밍의 목표는 비즈니스 로직과 사이드 이펙트를 분리하는 것이다.
- 함수형 아키텍처는 사이드 이펙트를 비즈니스 연산의 가장자리로 밀어내 분리를 이루는 데 도움이 된다. 이 방법으로, 사이드 이펙트를 다루는 코드를 최소화하면서 순수 함수 방식으로 작성된 코드의 양을 최대화할 수 있다.
- 함수형 아키텍처는 모든 코드를 함수형 코어와 가변 셸이라는 두 가지 범주로 나눈다. 가변 셸은 입력 데이터를 함수형 코어에 공급하고, 코어가 내린 결정을 사이드 이펙트로 변환한다.
- 함수형 아키텍처와 육각형 아키텍처의 차이는 사이드 이펙트의 처리에 있다. 함수형 아키텍처는 모든 사이드 이펙트를 도메인 계층 밖으로 밀어낸다. 이와 반대로, 육각형 아키텍처는 도메인 계층에만 한정돼 있는 한은 도메인 계층에 의해 만들어진 사이드 이펙트도 괜찮다. 극단적으로 함수형 아키텍처는 육각형 아키텍처다.
- 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 사이의 절충이며, 함수형 아키텍처는 유지 보수성 향상을 위해 성능을 희생한다.
- 모든 코드베이스를 함수형 아키텍처로 전환할 수는 없다. 함수형 아키텍처를 전략적으로 적용하라. 시스템의 복잡도와 중요성을 고려하라. 코드베이스가 단순하거나 그렇게 중요하지 않으면, 함수형 아키텍처에 필요한 초기 투자는 별 효과가 없다.
