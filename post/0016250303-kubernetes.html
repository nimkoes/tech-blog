<!DOCTYPE html><html lang="ko" class="__className_c5102c"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/tech-blog/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/tech-blog/_next/static/css/1f59140b53390c8f.css" data-precedence="next"/><link rel="stylesheet" href="/tech-blog/_next/static/css/86708423b213bf15.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/tech-blog/_next/static/chunks/webpack-55be747906e2abed.js"/><script src="/tech-blog/_next/static/chunks/fd9d1056-12d0224c61359539.js" async=""></script><script src="/tech-blog/_next/static/chunks/117-d2d2b15d916da2d9.js" async=""></script><script src="/tech-blog/_next/static/chunks/main-app-dc241a590481c956.js" async=""></script><script src="/tech-blog/_next/static/chunks/679-09931d2c20ac23c4.js" async=""></script><script src="/tech-blog/_next/static/chunks/app/layout-7b9eb4963e5bd58c.js" async=""></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6151583773425822" crossorigin="anonymous"></script><script src="/tech-blog/_next/static/chunks/app/post/%5Bslug%5D/page-5fc1a46522590ee2.js" async=""></script><meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)"/><meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)"/><meta name="naver-site-verification" content="1df124e1d8331da4467178ffddd6188e1d413576"/><meta name="google-adsense-account" content="ca-pub-6151583773425822"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="dns-prefetch" href="https://fonts.gstatic.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="anonymous"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><title>Pod - NodeScheduling | Nimkoes Tech Blog</title><meta name="description" content="기본 설명"/><meta name="application-name" content="Nimkoes Tech Blog"/><link rel="author" href="https://nimkoes.github.io/tech-blog"/><meta name="author" content="Nimkoes"/><link rel="manifest" href="/tech-blog/site.webmanifest" crossorigin="use-credentials"/><meta name="keywords" content="tech-blog,backend,software architect,infrastructure,development"/><meta name="creator" content="Nimkoes"/><meta name="publisher" content="Nimkoes"/><meta name="robots" content="index, follow, nocache"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><meta name="category" content="technology"/><link rel="canonical" href="https://nimkoes.github.io/tech-blog"/><link rel="alternate" hrefLang="ko-KR" href="https://nimkoes.github.io/tech-blog"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta name="google-adsense-account" content="ca-pub-6151583773425822"/><meta property="og:title" content="Nimkoes Tech Blog - 개발자의 기술 이야기"/><meta property="og:description" content="I work diligently to become lazy ☕"/><meta property="og:url" content="https://nimkoes.github.io/tech-blog"/><meta property="og:site_name" content="Nimkoes Tech Blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:image" content="https://nimkoes.github.io/tech-blog/og-image.png"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="Nimkoes Tech Blog"/><meta property="og:image:type" content="image/png"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@nimkoes"/><meta name="twitter:creator" content="@nimkoes"/><meta name="twitter:title" content="Nimkoes Tech Blog"/><meta name="twitter:description" content="I work diligently to become lazy ☕"/><meta name="twitter:image" content="https://nimkoes.github.io/tech-blog/og-image.png"/><link rel="icon" href="/tech-blog/favicon.ico" sizes="any"/><link rel="icon" href="/tech-blog/icon.svg" type="image/svg+xml"/><link rel="icon" href="/tech-blog/favicon-32x32.png" sizes="32x32" type="image/png"/><link rel="icon" href="/tech-blog/favicon-16x16.png" sizes="16x16" type="image/png"/><link rel="apple-touch-icon" href="/tech-blog/apple-touch-icon.png" sizes="180x180" type="image/png"/><link rel="mask-icon" href="/tech-blog/safari-pinned-tab.svg" color="#5bbad5"/><meta name="next-size-adjust"/><script src="/tech-blog/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="layout_home__0Lbpw"><aside class="NavigationView_navigationView__9z_1q"><div class="NavigationView_navigation__E0_xU"><button class="Button_button__aem_D Button_icon__S9jrr Button_medium__xLUiz NavigationView_navButton__QKsJg " aria-label="카테고리 보기"></button><button class="Button_button__aem_D Button_icon__S9jrr Button_medium__xLUiz NavigationView_navButton__QKsJg " aria-label="로그 보기"></button></div></aside><div class="layout_page__rCnOA" style="height:100vh"><div class="layout_subPage__irpRs"><div class="layout_contentsView__k4Q_k contentsView"><div><header class="PostHeader_postHeader__OohTH"><h1 class="PostHeader_title__NoKGt">Pod - NodeScheduling</h1><p class="PostHeader_description__moC_r"></p><div class="PostHeader_meta__9Swgx"><span>nimkoes</span><span>2021-03-02</span></div><div class="PostHeader_tags__lGQ1Q"><span class="PostHeader_tag__Jf7BC">Kubernetes</span><span class="PostHeader_tag__Jf7BC">k8s</span><span class="PostHeader_tag__Jf7BC">infra</span></div></header><div class="TableOfContents_tocWrapper__wUNrb "><div class="TableOfContents_tocBox__GAFU7"><div class="TableOfContents_tocHeader__EikQq"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="20" height="16" rx="3" stroke="#CCCCCC" stroke-width="1.5"></rect><circle cx="6" cy="8" r="1.5" fill="#CCCCCC"></circle><circle cx="6" cy="12" r="1.5" fill="#CCCCCC"></circle><circle cx="6" cy="16" r="1.5" fill="#CCCCCC"></circle><line x1="9" y1="8" x2="18" y2="8" stroke="#CCCCCC" stroke-width="1.5"></line><line x1="9" y1="12" x2="18" y2="12" stroke="#CCCCCC" stroke-width="1.5"></line><line x1="9" y1="16" x2="18" y2="16" stroke="#CCCCCC" stroke-width="1.5"></line></svg><span class="TableOfContents_tocText__Mmsk2">Table of Contents</span></div><ul></ul></div></div><article class="page_markdown__SVl4d"><div class="KakaoAdFit_adContainer__TWxMq page_topAd__ctbB7"></div><div><p>Pod 는 기본적으로 Scheduler 에 의해 Node 에 할당 되지만 사용자의 의도에 의해 Node 를 지정할 수 있고, 운영자가 특정 노드를 사용하지 못하도록 관리 할 수도 있다.</p>
<h1>Node 선택 (NodeName, NodeSelector, NodeAffinity)</h1>
<p>Pod 를 특정 Node 에 할당 되도록 선택하기 위한 용도로 사용 한다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-01.png" alt="0016-01"></p>
<p>Node1, Node2, Node3 은 서버가 한국에 있고, Node4, Node5 는 미국에 있다고 가정 한다. 이 상태에서 Pod 를 하나 만들면 k8s Scheduler 는 cpu 자원이 가장 많은 Node 에
이 Pod 를 할당 한다.</p><h2>NodeName</h2>
<p>NodeName 을 사용하면 Scheduler 와는 상관 없이 바로 해당 Node 의 이름으로 Pod 가 할당 된다. 명시적으로 Node 에 할당 할 수 있어서 좋아 보이지만 운영 환경에서는 Node 가 추가, 삭제
되면서 Node 이름이 계속 바뀔 수 있기 때문에 잘 사용하지 않는다.</p><h2>NodeSelector</h2>
<p>특정 Node 를 선택할 때 권장하는 방법은 NodeSelector 인데, Pod 에 key 와 value 를 설정하면, 해당 Label 이 작성 된 Node 에 할당 된다. 하지만 Label 의 특성 상 다수의
Node 에 동일한 Label 을 설정할 수 있기 때문에 Pod 에 NodeSelector 를 설정하면 Scheduler 에 의해 자원이 많은 Node 에 Pod 가 할당 된다. NodeSelector 에는 단점이
있는데, key 와 value 가 완전히 일치 해야하고 만약 매칭하는 Label 이 없으면 Pod 가 어느 Node 에도 할당 되지 않아 오류가 발생한다.</p><h2>NodeAffinity</h2>
<p>이 단점을 보완한 방법이 NodeAffinity 이다. Pod 에 key 만 설정해도 해당 그룹 중에 Scheduler 를 통해 자원이 많은 Node 에 Pod 가 할당 된다. 만약 조건에 맞는 key 를 가진
Node 가 없더라도 Scheduler 가 판단해서 자원이 많은 Node 에 할당 되도록 옵션을 설정할 수 있다.</p>
<h1>Pod 간 집중, 분산 (Pod Affinity, Anti-Affinity)</h1>
<p>다수의 Pod 들을 하나의 Node 에 집중해서 할당 하거나 Pod 간 겹치는 Node 없이 분산해서 할당할 수 있다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-02.png" alt="0016-02"></p></div><div class="GoogleAdsense_adContainer__8AKIp page_middleAd__4qBOv"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6151583773425822" data-ad-slot="your-ad-slot-id" data-ad-format="auto" data-full-width-responsive="true"></ins></div><div><h2>Pod Affinity</h2>
<p>예를 들어 위와 같이 Web 과 Server 가 있고 이 두 Pod 는 Hostpath 를 쓰는 하나의 PV 에 연결 되어 있을 때, 두 Pod 는 같은 Node 에 있어야 문제가 발생하지 않는다. 그래서 두 Pod
를 같은 Node 에 할당 하려면 Pod Affinity 를 사용해야 한다. 처음 Web Pod 가 Scheduler 에 의해 특정 Node 에 할당 되면 그 Hostpath 에 PV 가 생기게 된다. 다음으로
Server Pod 가 Web Pod 가 있는 Node 에 들어가게 하려면 Server Pod 를 만들 때 Pod Affinity 속성을 넣고 Web Pod 에 있는 Label 을 지정하면 된다.</p><h2>Anti-Affinity</h2>
<p>Master 가 다운되면 Slave 가 백업을 해줘야 하는 관계라고 할 때, 이 두 Pod 가 같은 Node 에 들어갈 경우 Node 가 다운 되었을 때 둘 다 장애가 발생한다. 그래서 서로 다른 Node 에
Scheduling 되어야 한다. 그렇기 때문에 Master 가 Scheduler 에 의해 어느 한 Node 에 들어가고 Slave Pod 를 만들 때 Anti-Affinity 를 설정하여 Master Pod 의
key, value 를 설정하면 Slave Pod 는 Master Pod 와 다른 Node 에 만들어 진다.</p><h2>Node 할당 제한 (Toleration, Taint)</h2>
<p>특정 Node 에는 Pod 가 할당 되지 않도록 제한하기 위해 사용 한다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-03.png" alt="0016-03"></p>
<p>Node5 는 높은 사양의 그래픽을 요구하는 Application 을 운영하는 용도로 GPU 를 설정 했을 때, 운영자는 Taint 라는 것을 설정 해둔다. 그러면 일반적인 Pod 들은 Scheduler 가 이
Node 로 할당하지 않기 때문에 Pod 가 직접 Node5 를 지정해서 할당하려 해도 불가능 하다. 이 Node 에 Pod 를 할당 하려면 Pod 는 Toleration 을 설정 해야 한다.</p><h2>Node Affinity</h2>
<p><img src="/tech-blog/resources/images/kubernetes/0016-04.png" alt="0016-04"></p>
<p>Selector 와 Label 은 key 와 value 가 모두 같아야 매칭이 되지만 matchExpressions 는 다양한 조합으로 Pod 들을 선택할 수 있다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-05.png" alt="0016-05"></p>
<p>Node Affinity 를 사용할 때 matchExpressions 속성을 통해 Pod 는 Node 를 선택할 수 있다. key 를 그룹핑 단위로 Pod 를 하위 식별자로 하는 Label 들이 Node 에 설정되어
있고, Pod 를 key 가 kr 인 그룹 안에 할당할 때 matchExpressions 를 사용할 수 있다. 그러면 Scheduler 가 자원이 많은 Node 쪽으로 Pod 를 배치 한다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-06.png" alt="0016-06"></p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-07.png" alt="0016-07"></p>
<p>Node Affinity 에서 matchExpressions 에 Operator 로 사용할 수 있는 종류는 위와 같다. 대부분 ReplicaSet 에서 보았던 내용과 동일하고, 아래쪽의 Gt 와 Lt 는 사용자가
지정한 value 보다 값이 크거나 작은 Node 를 선택하는 옵션이 추가 되었다.</p>
<p>Node Affinity 의 다음 속성으로 required 와 preferred 가 있다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-08.png" alt="0016-08"></p>
<p>위와 같이 두 개의 Node 가 있을 때, 만약 Node Affinity 로 required 속성을 가진 Pod 가 Node 에는 없는 key 를 가지고 있을 경우 이 Pod 는 Node 에 절대로
Scheduling 되지 않는다. 하지만 만약 key 가 ch 인 Node 가 있으면 선호할 뿐이고 반드시 그 Node 에 할당 되어야 하는 Pod 가 아닌 경우에는 required 대신 preferred 옵션을
작성하면 해당 key 가 없더라도 적절한 Node 에 할당 된다.</p>
<p>preferred 에는 weight 라는 필수 값이 있다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-09.png" alt="0016-09"></p>
<p>key 가 다른 Label 을 가진 두 개의 Node 가 있고, cpu 는 50과 30으로 Node1 이 더 많다고 하자. 그리고 preferred 속성을 가진 Pod 를 만드는데, 두 Node 의 key 가 모두
있기 때문에 두 노드 중 cpu 자원이 많은 Node1 에 할당 된다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-10.png" alt="0016-10"></p>
<p>여기에 선호도에 대한 가중치를 주는 의미로 weight 값을 줄 수 있다. 이 Pod 는 key 가 us 이거나 kr 인 Node 에 할당 될 수 있지만, key 가 kr 인 Node 에 가중치를 조금 더 주겠다고
설정 했다. 그러면 Scheduler 는 최초 cpu 자원만 보고 Node1 에 할당 하려 했지만, Pod 의 가중치가 합산 되어 다시 점수를 매긴다. 그 결과 최종 점수가 더 높은 Node 에 Pod 를 할당
한다.</p>
<p>점수를 계산하는 방식이 이렇게 간단하지 않지만 대략적인 weight 속성에 대한 개념은 설명한 내용과 같다.</p>
<h1>Pod Affinity, Pod Anti-Affinity</h1>
<p><img src="/tech-blog/resources/images/kubernetes/0016-11.png" alt="0016-11"></p>
<p>type: web 이라는 Label 을 가진 web Pod 가 Scheduler 에 의해 Node1에 할당 되었다. 만약 이 web Pod 와 같은 Node 에 Pod 를 할당 하려면 Pod Affinity 라는
속성으로 matchExpressions 를 사용할 수 있는데, 이 matchExpressions 는 Node 의 Label 이 아닌 Pod 의 Label 과 매칭 된다. 그래서 web Pod 와 같은 Node1 에
할당될 수 있다. 추가로 topologyKey 는 Node 의 key 를 본다. 다시 말하면 matchExpressions 에 있는 조건에 맞는 Pod 를 찾지만 Node 의 key 가 a-team 인 범위에서만
찾겠다는 의미이다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-12.png" alt="0016-12"></p>
<p>만약 web Pod 가 Node3 에 할당 되었었다면, server Pod 는 pending 상태가 되고 설정된 조건이 만족 할 때까지 Node 에 할당 되지 않는다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-13.png" alt="0016-13"></p>
<p>다음으로 Pod Anti-Affinity 는 type: master 라는 Label 을 가진 master Pod 가 Node4 에 Schduling 되었을 때, 이와 다른 Node 에 Pod 를 할당하기 위해
slave Pod 에 Anti-Affinity 를 설정하고 matchExpressions 로 master Pod 의 Label 을 설정한다. 마찬가지로 topologyKey 를 설정하여 b-team 이라는 key 를
가진 Node 로 범위를 제한 할 수 있다.</p>
<h1>Taint, Toleration</h1>
<p><img src="/tech-blog/resources/images/kubernetes/0016-14.png" alt="0016-14"></p>
<p>Node1 은 다른 Node 들과는 다르게 GPU 가 구성되어 있다. 그리고 일반적인 Pod 들이 Node1 에 할당되는 것을 막으려면 Taint 라는 것을 Node 에 설정한다. Taint 에는 식별자로 사용하는
Label 인 key 와 value 가 있고, effect 라는 옵션에 값을 NoSchedule 로 주면 다른 Pod 들이 이 Node 에 할당되지 않는다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-15.png" alt="0016-15"></p>
<p>만약 Pod 가 GPU 자원을 사용해야 하는 경우 해당 Pod 에 Toleration 을 설정하여 Taint 가 설정 된 Node 에 Pod 를 할당할 수 있다. 내용으로는 key, operator, value,
effect 가 있는데 Taint 의 Label 과 일치해야 한다. 하나라도 다른 값을 가질 경우 Toleration 을 설정 했다고 하더라도 Taint 가 설정 된 Node 에 할당될 수 없다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-16.png" alt="0016-16"></p>
<p>추가로 Pod 의 Toleration 설정 값으로 매칭하는 Taint 가 있는 Node 를 찾는다고 생각할 수 있는데 그렇지 않다. Pod 가 Node1 에 Scheduling 되었을 때, Pod 에 Node1 의
Taint 와 매칭하는 Toleration 이 있기 때문에 Node1 에 할당될 수 있는 것이다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-17.png" alt="0016-17"></p>
<p>그렇기 때문에 Pod 에 별도의 Node Selector 를 설정하여 특정 Pod 가 Node1 에 할당될 수 있도록 해야 한다.</p>
<p>즉, Taint 가 설정 된 Node 에는 아무 Pod 나 할당될 수 없으며, 해당 Taint 와 매칭하는 Toleration 을 설정한 Pod 만 할당될 수 있지만, Pod 가 특정 Node 에 Scheduling
되도록 하려면 별도의 옵션을 추가 해야 한다.</p>
<p>effect 는 NoShcedule, PreferNoSchedule, NoExecute 값을 가진다. PreferNoSchedule 은 가급적 Scheduling 이 되지 않도록 하는 것으로 Pod 가 다른 Node
에 할당될 수 없는 상황이라면 Taint 가 설정 된 Node 라도 Pod 가 할당될 수 있다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-18.png" alt="0016-18"></p>
<p>NoExecute 는 Pod1 이 Node2 할당 되어 운영 중에 NoSchedule effect 를 가진 Taint 를 설정하면 어떻게 될까? Node Affinity, Pod Affinity 그리고
NoSchedule 설정 값은 Pod 가 최초 Node 를 선택할 때에만 영향을 주는 것으로 이미 Pod 가 Node 에 할당 된 이후에는 Node Label 을 수정 하거나 Taint 를 설정 한다고 해서 Pod
가 삭제되거나 하지 않는다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-19.png" alt="0016-19"></p>
<p>하지만 Pod 가 Node 에 이미 할당 되어 운영중일 때 NoExecute 값을 가진 Taint 를 설정하게 되면 Pod는 삭제 된다.</p>
<p><img src="/tech-blog/resources/images/kubernetes/0016-20.png" alt="0016-20"></p>
<p>만약 Node3 의 Pod2 가 삭제 되지 않도록 하기 위해서는 Pod 를 만들 때 Taint 와 매칭하는 Toleration 을 설정하면 된다. tolerationSeconds 라는 속성이 있는데 이 값에 설정된
시간이 경과한 후 Pod 가 삭제 된다. 만약 tolerationSeconds 속성을 사용하지 않으면 Pod 는 삭제 되지 않는다.</p>
<p>NoSchedule 과 NoExecute 는 k8s 에서 자주 사용하는 속성으로 개념을 알아두면 좋다. NoSchedule 은 Master Node 에 기본적으로 설정되어 있어서 Pod 를 만들 때 Master 에
할당되지 않도록 하는데 사용 된다. 만약 ReplicaSet 을 사용해서 Pod 를 운영 중일 때 Node 에 장애가 발생하면 k8s 는 해당 Node 의 Pod 들이 정상 동작하지 않을 수 있기 때문에
NoExecute 속성을 가진 Taint 를 자체적으로 장애가 발생한 Node 에 설정한다. 그러면 ReplicaSet 은 자신의 Pod 가 없어졌기 때문에 다른 Node 에 Pod 를 다시 만들어서 Service
가 유지될 수 있도록 해준다.</p></div><div class="GoogleAdsense_adContainer__8AKIp page_bottomAd__f0OO_"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6151583773425822" data-ad-slot="your-ad-slot-id" data-ad-format="auto" data-full-width-responsive="true"></ins></div></article></div><div class="page_floatingButtons__qJiZU"><button class="GoToHome_goToHome__Es1L5"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2L2 7V14H6V9H10V14H14V7L8 2Z" fill="currentColor"></path></svg></button></div><button class="ScrollToTop_scrollToTop__7NKxR " aria-label="Scroll to top" type="button"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3L3 8M8 3L13 8M8 3V13"></path></svg></button></div></div></div><script src="/tech-blog/_next/static/chunks/webpack-55be747906e2abed.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/tech-blog/_next/static/media/a34f9d1faa5f3315-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/tech-blog/_next/static/css/1f59140b53390c8f.css\",\"style\"]\n3:HL[\"/tech-blog/_next/static/css/86708423b213bf15.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I[2846,[],\"\"]\n7:I[4707,[],\"\"]\n9:I[6423,[],\"\"]\na:I[4829,[\"679\",\"static/chunks/679-09931d2c20ac23c4.js\",\"185\",\"static/chunks/app/layout-7b9eb4963e5bd58c.js\"],\"default\"]\nc:I[1060,[],\"\"]\n8:[\"slug\",\"0016250303-kubernetes\",\"d\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L4\",null,{\"buildId\":\"22virKqFA9DE3eXNEajrC\",\"assetPrefix\":\"/tech-blog\",\"urlParts\":[\"\",\"post\",\"0016250303-kubernetes\"],\"initialTree\":[\"\",{\"children\":[\"post\",{\"children\":[[\"slug\",\"0016250303-kubernetes\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"0016250303-kubernetes\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"post\",{\"children\":[[\"slug\",\"0016250303-kubernetes\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L5\",\"$L6\",[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/tech-blog/_next/static/css/86708423b213bf15.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]]],null],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\",\"$8\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"post\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/tech-blog/_next/static/css/1f59140b53390c8f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"__className_c5102c\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\",\"media\":\"(prefers-color-scheme: light)\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#000000\",\"media\":\"(prefers-color-scheme: dark)\"}],[\"$\",\"meta\",null,{\"name\":\"naver-site-verification\",\"content\":\"1df124e1d8331da4467178ffddd6188e1d413576\"}],[\"$\",\"meta\",null,{\"name\":\"google-adsense-account\",\"content\":\"ca-pub-6151583773425822\"}],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://fonts.gstatic.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6151583773425822\",\"crossOrigin\":\"anonymous\"}]]}],[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]\n"])</script><script>self.__next_f.push([1,"e:I[2089,[\"605\",\"static/chunks/app/post/%5Bslug%5D/page-5fc1a46522590ee2.js\"],\"default\"]\nf:I[3299,[\"605\",\"static/chunks/app/post/%5Bslug%5D/page-5fc1a46522590ee2.js\"],\"default\"]\n11:I[1040,[\"605\",\"static/chunks/app/post/%5Bslug%5D/page-5fc1a46522590ee2.js\"],\"default\"]\n13:I[2786,[\"605\",\"static/chunks/app/post/%5Bslug%5D/page-5fc1a46522590ee2.js\"],\"default\"]\n14:I[6798,[\"605\",\"static/chunks/app/post/%5Bslug%5D/page-5fc1a46522590ee2.js\"],\"default\"]\n10:T8f7,"])</script><script>self.__next_f.push([1,"\u003cp\u003ePod 는 기본적으로 Scheduler 에 의해 Node 에 할당 되지만 사용자의 의도에 의해 Node 를 지정할 수 있고, 운영자가 특정 노드를 사용하지 못하도록 관리 할 수도 있다.\u003c/p\u003e\n\u003ch1\u003eNode 선택 (NodeName, NodeSelector, NodeAffinity)\u003c/h1\u003e\n\u003cp\u003ePod 를 특정 Node 에 할당 되도록 선택하기 위한 용도로 사용 한다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-01.png\" alt=\"0016-01\"\u003e\u003c/p\u003e\n\u003cp\u003eNode1, Node2, Node3 은 서버가 한국에 있고, Node4, Node5 는 미국에 있다고 가정 한다. 이 상태에서 Pod 를 하나 만들면 k8s Scheduler 는 cpu 자원이 가장 많은 Node 에\n이 Pod 를 할당 한다.\u003c/p\u003e\u003ch2\u003eNodeName\u003c/h2\u003e\n\u003cp\u003eNodeName 을 사용하면 Scheduler 와는 상관 없이 바로 해당 Node 의 이름으로 Pod 가 할당 된다. 명시적으로 Node 에 할당 할 수 있어서 좋아 보이지만 운영 환경에서는 Node 가 추가, 삭제\n되면서 Node 이름이 계속 바뀔 수 있기 때문에 잘 사용하지 않는다.\u003c/p\u003e\u003ch2\u003eNodeSelector\u003c/h2\u003e\n\u003cp\u003e특정 Node 를 선택할 때 권장하는 방법은 NodeSelector 인데, Pod 에 key 와 value 를 설정하면, 해당 Label 이 작성 된 Node 에 할당 된다. 하지만 Label 의 특성 상 다수의\nNode 에 동일한 Label 을 설정할 수 있기 때문에 Pod 에 NodeSelector 를 설정하면 Scheduler 에 의해 자원이 많은 Node 에 Pod 가 할당 된다. NodeSelector 에는 단점이\n있는데, key 와 value 가 완전히 일치 해야하고 만약 매칭하는 Label 이 없으면 Pod 가 어느 Node 에도 할당 되지 않아 오류가 발생한다.\u003c/p\u003e\u003ch2\u003eNodeAffinity\u003c/h2\u003e\n\u003cp\u003e이 단점을 보완한 방법이 NodeAffinity 이다. Pod 에 key 만 설정해도 해당 그룹 중에 Scheduler 를 통해 자원이 많은 Node 에 Pod 가 할당 된다. 만약 조건에 맞는 key 를 가진\nNode 가 없더라도 Scheduler 가 판단해서 자원이 많은 Node 에 할당 되도록 옵션을 설정할 수 있다.\u003c/p\u003e\n\u003ch1\u003ePod 간 집중, 분산 (Pod Affinity, Anti-Affinity)\u003c/h1\u003e\n\u003cp\u003e다수의 Pod 들을 하나의 Node 에 집중해서 할당 하거나 Pod 간 겹치는 Node 없이 분산해서 할당할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-02.png\" alt=\"0016-02\"\u003e\u003c/p\u003e"])</script><script>self.__next_f.push([1,"12:T2829,"])</script><script>self.__next_f.push([1,"\u003ch2\u003ePod Affinity\u003c/h2\u003e\n\u003cp\u003e예를 들어 위와 같이 Web 과 Server 가 있고 이 두 Pod 는 Hostpath 를 쓰는 하나의 PV 에 연결 되어 있을 때, 두 Pod 는 같은 Node 에 있어야 문제가 발생하지 않는다. 그래서 두 Pod\n를 같은 Node 에 할당 하려면 Pod Affinity 를 사용해야 한다. 처음 Web Pod 가 Scheduler 에 의해 특정 Node 에 할당 되면 그 Hostpath 에 PV 가 생기게 된다. 다음으로\nServer Pod 가 Web Pod 가 있는 Node 에 들어가게 하려면 Server Pod 를 만들 때 Pod Affinity 속성을 넣고 Web Pod 에 있는 Label 을 지정하면 된다.\u003c/p\u003e\u003ch2\u003eAnti-Affinity\u003c/h2\u003e\n\u003cp\u003eMaster 가 다운되면 Slave 가 백업을 해줘야 하는 관계라고 할 때, 이 두 Pod 가 같은 Node 에 들어갈 경우 Node 가 다운 되었을 때 둘 다 장애가 발생한다. 그래서 서로 다른 Node 에\nScheduling 되어야 한다. 그렇기 때문에 Master 가 Scheduler 에 의해 어느 한 Node 에 들어가고 Slave Pod 를 만들 때 Anti-Affinity 를 설정하여 Master Pod 의\nkey, value 를 설정하면 Slave Pod 는 Master Pod 와 다른 Node 에 만들어 진다.\u003c/p\u003e\u003ch2\u003eNode 할당 제한 (Toleration, Taint)\u003c/h2\u003e\n\u003cp\u003e특정 Node 에는 Pod 가 할당 되지 않도록 제한하기 위해 사용 한다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-03.png\" alt=\"0016-03\"\u003e\u003c/p\u003e\n\u003cp\u003eNode5 는 높은 사양의 그래픽을 요구하는 Application 을 운영하는 용도로 GPU 를 설정 했을 때, 운영자는 Taint 라는 것을 설정 해둔다. 그러면 일반적인 Pod 들은 Scheduler 가 이\nNode 로 할당하지 않기 때문에 Pod 가 직접 Node5 를 지정해서 할당하려 해도 불가능 하다. 이 Node 에 Pod 를 할당 하려면 Pod 는 Toleration 을 설정 해야 한다.\u003c/p\u003e\u003ch2\u003eNode Affinity\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-04.png\" alt=\"0016-04\"\u003e\u003c/p\u003e\n\u003cp\u003eSelector 와 Label 은 key 와 value 가 모두 같아야 매칭이 되지만 matchExpressions 는 다양한 조합으로 Pod 들을 선택할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-05.png\" alt=\"0016-05\"\u003e\u003c/p\u003e\n\u003cp\u003eNode Affinity 를 사용할 때 matchExpressions 속성을 통해 Pod 는 Node 를 선택할 수 있다. key 를 그룹핑 단위로 Pod 를 하위 식별자로 하는 Label 들이 Node 에 설정되어\n있고, Pod 를 key 가 kr 인 그룹 안에 할당할 때 matchExpressions 를 사용할 수 있다. 그러면 Scheduler 가 자원이 많은 Node 쪽으로 Pod 를 배치 한다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-06.png\" alt=\"0016-06\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-07.png\" alt=\"0016-07\"\u003e\u003c/p\u003e\n\u003cp\u003eNode Affinity 에서 matchExpressions 에 Operator 로 사용할 수 있는 종류는 위와 같다. 대부분 ReplicaSet 에서 보았던 내용과 동일하고, 아래쪽의 Gt 와 Lt 는 사용자가\n지정한 value 보다 값이 크거나 작은 Node 를 선택하는 옵션이 추가 되었다.\u003c/p\u003e\n\u003cp\u003eNode Affinity 의 다음 속성으로 required 와 preferred 가 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-08.png\" alt=\"0016-08\"\u003e\u003c/p\u003e\n\u003cp\u003e위와 같이 두 개의 Node 가 있을 때, 만약 Node Affinity 로 required 속성을 가진 Pod 가 Node 에는 없는 key 를 가지고 있을 경우 이 Pod 는 Node 에 절대로\nScheduling 되지 않는다. 하지만 만약 key 가 ch 인 Node 가 있으면 선호할 뿐이고 반드시 그 Node 에 할당 되어야 하는 Pod 가 아닌 경우에는 required 대신 preferred 옵션을\n작성하면 해당 key 가 없더라도 적절한 Node 에 할당 된다.\u003c/p\u003e\n\u003cp\u003epreferred 에는 weight 라는 필수 값이 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-09.png\" alt=\"0016-09\"\u003e\u003c/p\u003e\n\u003cp\u003ekey 가 다른 Label 을 가진 두 개의 Node 가 있고, cpu 는 50과 30으로 Node1 이 더 많다고 하자. 그리고 preferred 속성을 가진 Pod 를 만드는데, 두 Node 의 key 가 모두\n있기 때문에 두 노드 중 cpu 자원이 많은 Node1 에 할당 된다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-10.png\" alt=\"0016-10\"\u003e\u003c/p\u003e\n\u003cp\u003e여기에 선호도에 대한 가중치를 주는 의미로 weight 값을 줄 수 있다. 이 Pod 는 key 가 us 이거나 kr 인 Node 에 할당 될 수 있지만, key 가 kr 인 Node 에 가중치를 조금 더 주겠다고\n설정 했다. 그러면 Scheduler 는 최초 cpu 자원만 보고 Node1 에 할당 하려 했지만, Pod 의 가중치가 합산 되어 다시 점수를 매긴다. 그 결과 최종 점수가 더 높은 Node 에 Pod 를 할당\n한다.\u003c/p\u003e\n\u003cp\u003e점수를 계산하는 방식이 이렇게 간단하지 않지만 대략적인 weight 속성에 대한 개념은 설명한 내용과 같다.\u003c/p\u003e\n\u003ch1\u003ePod Affinity, Pod Anti-Affinity\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-11.png\" alt=\"0016-11\"\u003e\u003c/p\u003e\n\u003cp\u003etype: web 이라는 Label 을 가진 web Pod 가 Scheduler 에 의해 Node1에 할당 되었다. 만약 이 web Pod 와 같은 Node 에 Pod 를 할당 하려면 Pod Affinity 라는\n속성으로 matchExpressions 를 사용할 수 있는데, 이 matchExpressions 는 Node 의 Label 이 아닌 Pod 의 Label 과 매칭 된다. 그래서 web Pod 와 같은 Node1 에\n할당될 수 있다. 추가로 topologyKey 는 Node 의 key 를 본다. 다시 말하면 matchExpressions 에 있는 조건에 맞는 Pod 를 찾지만 Node 의 key 가 a-team 인 범위에서만\n찾겠다는 의미이다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-12.png\" alt=\"0016-12\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 web Pod 가 Node3 에 할당 되었었다면, server Pod 는 pending 상태가 되고 설정된 조건이 만족 할 때까지 Node 에 할당 되지 않는다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-13.png\" alt=\"0016-13\"\u003e\u003c/p\u003e\n\u003cp\u003e다음으로 Pod Anti-Affinity 는 type: master 라는 Label 을 가진 master Pod 가 Node4 에 Schduling 되었을 때, 이와 다른 Node 에 Pod 를 할당하기 위해\nslave Pod 에 Anti-Affinity 를 설정하고 matchExpressions 로 master Pod 의 Label 을 설정한다. 마찬가지로 topologyKey 를 설정하여 b-team 이라는 key 를\n가진 Node 로 범위를 제한 할 수 있다.\u003c/p\u003e\n\u003ch1\u003eTaint, Toleration\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-14.png\" alt=\"0016-14\"\u003e\u003c/p\u003e\n\u003cp\u003eNode1 은 다른 Node 들과는 다르게 GPU 가 구성되어 있다. 그리고 일반적인 Pod 들이 Node1 에 할당되는 것을 막으려면 Taint 라는 것을 Node 에 설정한다. Taint 에는 식별자로 사용하는\nLabel 인 key 와 value 가 있고, effect 라는 옵션에 값을 NoSchedule 로 주면 다른 Pod 들이 이 Node 에 할당되지 않는다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-15.png\" alt=\"0016-15\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 Pod 가 GPU 자원을 사용해야 하는 경우 해당 Pod 에 Toleration 을 설정하여 Taint 가 설정 된 Node 에 Pod 를 할당할 수 있다. 내용으로는 key, operator, value,\neffect 가 있는데 Taint 의 Label 과 일치해야 한다. 하나라도 다른 값을 가질 경우 Toleration 을 설정 했다고 하더라도 Taint 가 설정 된 Node 에 할당될 수 없다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-16.png\" alt=\"0016-16\"\u003e\u003c/p\u003e\n\u003cp\u003e추가로 Pod 의 Toleration 설정 값으로 매칭하는 Taint 가 있는 Node 를 찾는다고 생각할 수 있는데 그렇지 않다. Pod 가 Node1 에 Scheduling 되었을 때, Pod 에 Node1 의\nTaint 와 매칭하는 Toleration 이 있기 때문에 Node1 에 할당될 수 있는 것이다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-17.png\" alt=\"0016-17\"\u003e\u003c/p\u003e\n\u003cp\u003e그렇기 때문에 Pod 에 별도의 Node Selector 를 설정하여 특정 Pod 가 Node1 에 할당될 수 있도록 해야 한다.\u003c/p\u003e\n\u003cp\u003e즉, Taint 가 설정 된 Node 에는 아무 Pod 나 할당될 수 없으며, 해당 Taint 와 매칭하는 Toleration 을 설정한 Pod 만 할당될 수 있지만, Pod 가 특정 Node 에 Scheduling\n되도록 하려면 별도의 옵션을 추가 해야 한다.\u003c/p\u003e\n\u003cp\u003eeffect 는 NoShcedule, PreferNoSchedule, NoExecute 값을 가진다. PreferNoSchedule 은 가급적 Scheduling 이 되지 않도록 하는 것으로 Pod 가 다른 Node\n에 할당될 수 없는 상황이라면 Taint 가 설정 된 Node 라도 Pod 가 할당될 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-18.png\" alt=\"0016-18\"\u003e\u003c/p\u003e\n\u003cp\u003eNoExecute 는 Pod1 이 Node2 할당 되어 운영 중에 NoSchedule effect 를 가진 Taint 를 설정하면 어떻게 될까? Node Affinity, Pod Affinity 그리고\nNoSchedule 설정 값은 Pod 가 최초 Node 를 선택할 때에만 영향을 주는 것으로 이미 Pod 가 Node 에 할당 된 이후에는 Node Label 을 수정 하거나 Taint 를 설정 한다고 해서 Pod\n가 삭제되거나 하지 않는다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-19.png\" alt=\"0016-19\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 Pod 가 Node 에 이미 할당 되어 운영중일 때 NoExecute 값을 가진 Taint 를 설정하게 되면 Pod는 삭제 된다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/tech-blog/resources/images/kubernetes/0016-20.png\" alt=\"0016-20\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 Node3 의 Pod2 가 삭제 되지 않도록 하기 위해서는 Pod 를 만들 때 Taint 와 매칭하는 Toleration 을 설정하면 된다. tolerationSeconds 라는 속성이 있는데 이 값에 설정된\n시간이 경과한 후 Pod 가 삭제 된다. 만약 tolerationSeconds 속성을 사용하지 않으면 Pod 는 삭제 되지 않는다.\u003c/p\u003e\n\u003cp\u003eNoSchedule 과 NoExecute 는 k8s 에서 자주 사용하는 속성으로 개념을 알아두면 좋다. NoSchedule 은 Master Node 에 기본적으로 설정되어 있어서 Pod 를 만들 때 Master 에\n할당되지 않도록 하는데 사용 된다. 만약 ReplicaSet 을 사용해서 Pod 를 운영 중일 때 Node 에 장애가 발생하면 k8s 는 해당 Node 의 Pod 들이 정상 동작하지 않을 수 있기 때문에\nNoExecute 속성을 가진 Taint 를 자체적으로 장애가 발생한 Node 에 설정한다. 그러면 ReplicaSet 은 자신의 Pod 가 없어졌기 때문에 다른 Node 에 Pod 를 다시 만들어서 Service\n가 유지될 수 있도록 해준다.\u003c/p\u003e"])</script><script>self.__next_f.push([1,"6:[[\"$\",\"div\",null,{\"className\":\"$undefined\",\"children\":[[\"$\",\"header\",null,{\"className\":\"PostHeader_postHeader__OohTH\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"PostHeader_title__NoKGt\",\"children\":\"Pod - NodeScheduling\"}],[\"$\",\"p\",null,{\"className\":\"PostHeader_description__moC_r\",\"children\":\"\"}],[\"$\",\"div\",null,{\"className\":\"PostHeader_meta__9Swgx\",\"children\":[[\"$\",\"span\",null,{\"className\":\"$undefined\",\"children\":\"nimkoes\"}],[\"$\",\"span\",null,{\"className\":\"$undefined\",\"children\":\"2021-03-02\"}]]}],[\"$\",\"div\",null,{\"className\":\"PostHeader_tags__lGQ1Q\",\"children\":[[\"$\",\"span\",\"Kubernetes\",{\"className\":\"PostHeader_tag__Jf7BC\",\"children\":\"Kubernetes\"}],[\"$\",\"span\",\"k8s\",{\"className\":\"PostHeader_tag__Jf7BC\",\"children\":\"k8s\"}],[\"$\",\"span\",\"infra\",{\"className\":\"PostHeader_tag__Jf7BC\",\"children\":\"infra\"}]]}]]}],[\"$\",\"$Le\",null,{}],[\"$\",\"article\",null,{\"className\":\"page_markdown__SVl4d\",\"children\":[[\"$\",\"$Lf\",null,{\"className\":\"page_topAd__ctbB7\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$10\"}}],[\"$\",\"$L11\",null,{\"className\":\"page_middleAd__4qBOv\",\"client\":\"ca-pub-6151583773425822\",\"slot\":\"your-ad-slot-id\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$12\"}}],[\"$\",\"$L11\",null,{\"className\":\"page_bottomAd__f0OO_\",\"client\":\"ca-pub-6151583773425822\",\"slot\":\"your-ad-slot-id\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page_floatingButtons__qJiZU\",\"children\":[\"$\",\"$L13\",null,{}]}],[\"$\",\"$L14\",null,{}]]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Pod - NodeScheduling | Nimkoes Tech Blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기본 설명\"}],[\"$\",\"meta\",\"4\",{\"name\":\"application-name\",\"content\":\"Nimkoes Tech Blog\"}],[\"$\",\"link\",\"5\",{\"rel\":\"author\",\"href\":\"https://nimkoes.github.io/tech-blog\"}],[\"$\",\"meta\",\"6\",{\"name\":\"author\",\"content\":\"Nimkoes\"}],[\"$\",\"link\",\"7\",{\"rel\":\"manifest\",\"href\":\"/tech-blog/site.webmanifest\",\"crossOrigin\":\"use-credentials\"}],[\"$\",\"meta\",\"8\",{\"name\":\"keywords\",\"content\":\"tech-blog,backend,software architect,infrastructure,development\"}],[\"$\",\"meta\",\"9\",{\"name\":\"creator\",\"content\":\"Nimkoes\"}],[\"$\",\"meta\",\"10\",{\"name\":\"publisher\",\"content\":\"Nimkoes\"}],[\"$\",\"meta\",\"11\",{\"name\":\"robots\",\"content\":\"index, follow, nocache\"}],[\"$\",\"meta\",\"12\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"meta\",\"13\",{\"name\":\"category\",\"content\":\"technology\"}],[\"$\",\"link\",\"14\",{\"rel\":\"canonical\",\"href\":\"https://nimkoes.github.io/tech-blog\"}],[\"$\",\"link\",\"15\",{\"rel\":\"alternate\",\"hrefLang\":\"ko-KR\",\"href\":\"https://nimkoes.github.io/tech-blog\"}],[\"$\",\"meta\",\"16\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"17\",{\"name\":\"google-adsense-account\",\"content\":\"ca-pub-6151583773425822\"}],[\"$\",\"meta\",\"18\",{\"property\":\"og:title\",\"content\":\"Nimkoes Tech Blog - 개발자의 기술 이야기\"}],[\"$\",\"meta\",\"19\",{\"property\":\"og:description\",\"content\":\"I work diligently to become lazy ☕\"}],[\"$\",\"meta\",\"20\",{\"property\":\"og:url\",\"content\":\"https://nimkoes.github.io/tech-blog\"}],[\"$\",\"meta\",\"21\",{\"property\":\"og:site_name\",\"content\":\"Nimkoes Tech Blog\"}],[\"$\",\"meta\",\"22\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"23\",{\"property\":\"og:image\",\"content\":\"https://nimkoes.github.io/tech-blog/og-image.png\"}],[\"$\",\"meta\",\"24\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"25\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"26\",{\"property\":\"og:image:alt\",\"content\":\"Nimkoes Tech Blog\"}],[\"$\",\"meta\",\"27\",{\"property\":\"og:image:type\",\"content\":\"image/png\"}],[\"$\",\"meta\",\"28\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"29\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"30\",{\"name\":\"twitter:site\",\"content\":\"@nimkoes\"}],[\"$\",\"meta\",\"31\",{\"name\":\"twitter:creator\",\"content\":\"@nimkoes\"}],[\"$\",\"meta\",\"32\",{\"name\":\"twitter:title\",\"content\":\"Nimkoes Tech Blog\"}],[\"$\",\"meta\",\"33\",{\"name\":\"twitter:description\",\"content\":\"I work diligently to become lazy ☕\"}],[\"$\",\"meta\",\"34\",{\"name\":\"twitter:image\",\"content\":\"https://nimkoes.github.io/tech-blog/og-image.png\"}],[\"$\",\"link\",\"35\",{\"rel\":\"icon\",\"href\":\"/tech-blog/favicon.ico\",\"sizes\":\"any\"}],[\"$\",\"link\",\"36\",{\"rel\":\"icon\",\"href\":\"/tech-blog/icon.svg\",\"type\":\"image/svg+xml\"}],[\"$\",\"link\",\"37\",{\"rel\":\"icon\",\"href\":\"/tech-blog/favicon-32x32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"}],[\"$\",\"link\",\"38\",{\"rel\":\"icon\",\"href\":\"/tech-blog/favicon-16x16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"}],[\"$\",\"link\",\"39\",{\"rel\":\"apple-touch-icon\",\"href\":\"/tech-blog/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"}],[\"$\",\"link\",\"40\",{\"rel\":\"mask-icon\",\"href\":\"/tech-blog/safari-pinned-tab.svg\",\"color\":\"#5bbad5\"}],[\"$\",\"meta\",\"41\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"5:null\n"])</script></body></html>